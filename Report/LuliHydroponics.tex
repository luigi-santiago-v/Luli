\documentclass[12pt]{article} % Set font size to 12pt
\usepackage[T1]{fontenc} % For setting T1 encoding instead of OT1, typewriter style quotation marks
\usepackage{graphicx} % For including images
\usepackage{float} % For figure placement
\usepackage{titlesec} % For customizing section titles
\usepackage{lipsum} % For generating dummy text during development
\usepackage{tocbibind} % For adding the table of contents to the table of contents
\usepackage[toc,page]{appendix} % For adding appendices
\usepackage{url} % For adding URLs in the bibliography
\usepackage{amsmath} % For IPC 2221 Formula
\usepackage{pdfpages} % To include PDFs
\usepackage{listings} % For code formatting
\usepackage{geometry} % For setting page margins
\usepackage{subcaption} % For subfigures
\geometry{a4paper, margin=1in} % Set page margins to 1 inch
% Force fonts to be embedded in PDF file
\usepackage{microtype} % Improve font rendering
\pdfminorversion=7
\pdfcompresslevel=9
\pdfobjcompresslevel=2


\lstnewenvironment{pythoncode}[1][]
{
    \lstset{
        language=Python,
        basicstyle=\small\ttfamily,
        keywordstyle=\color{blue},
        stringstyle=\color{orange},
        commentstyle=\color{gray},
        numbers=left,
        numberstyle=\tiny,
        numbersep=5pt,
        showstringspaces=false,
        breaklines=true,
        frame=single,
        captionpos=b,
        #1
    }
}
{} % This empty {} has to be there otherwise there's an error




\newcommand{\comment}[1]{} % Create a custom comment command
\begin{document}

% Cover Page
\begin{titlepage}
    \centering
    \vspace*{\stretch{1}}
    {\Large\bfseries SENIOR DESIGN PROJECT\par}
    \vspace{1.5cm}
    {\Large ECE 186B\par}
    \vspace{1.5cm}
    {\Large\bfseries LuLi Smart Cultivation: A Socially-Connected IoT Hydroponics Solution\par}
    \vspace{3cm}
    {\large California State University, Fresno\par}
    {\large Lyles College of Engineering\par}
    {\large Electrical and Computer Engineering Department\par}
    \vspace{2cm}
    {\large Dr. Gregory Kriehn\par}
    {\large Professor Roger Moore\par}
    \vspace{2cm}
    {\large BY\par}
    \vspace{1cm}
    {\large Liam Goss\par}
    %{\large Luigi Santiago-Villa\par} % Uncomment in group report
    \vspace{\stretch{2}}
\end{titlepage}
\pagebreak
% Table of Contents
\tableofcontents
\pagebreak

% List of Tables
\listoftables
\pagebreak

% List of Figures
\listoffigures
\pagebreak

% Abstract
\section*{Abstract}
\addcontentsline{toc}{section}{Abstract}
\noindent This project addresses food deserts by developing an accessible, internet-connected hydroponics system, enabling urban households to grow nutritious food. Leveraging temperature, humidity, light intensity, and water pH sensors, alongside UV lighting and a microcontroller, the system facilitates real-time plant health monitoring. A unique feature is its community-driven web application, allowing users to exchange growing tips and presets, significantly lowering the entry barrier for novices. Designed with a focus on food desert challenges and community engagement, the project aims to make home-grown crops viable for everyone. Over nine months and with a \$500 budget, this initiative will produce a functional prototype that demonstrates efficient crop cultivation, highlighting a technology-driven, socially inclusive approach to mitigate food insecurity in urban areas.

% Overview
\section*{Overview}
\addcontentsline{toc}{section}{Overview}
The hydroponics system has been successfully developed centered around user-friendliness, comprehensive data analytics, and internet connectivity. Functioning seamlessly as a household appliance, the initiative effectively addresses the crucial need for access to nutritious food in areas identified as food deserts. The automated system comprises multiple sensors for monitoring temperature, humidity, light intensity, and water pH, alongside a UV lighting system, water reservoir, water pump, and a microcontroller. These integrated components provide end-users with real-time insights into plant health and nutrient metrics.
\newline
\newline
\noindent Additionally, a web application has been developed to facilitate user interaction, enabling the sharing of insights, posing queries, and exchanging settings presets. Serving as the central nexus for accessing sensor data and engaging with community-driven inputs, this platform significantly enhances user experience. Notably, the solution stands out from existing market offerings because of its meticulous design tailored to address the unique challenges of food deserts and foster reliance on local communities through social networking.
\newline
\newline
\noindent The project, spanning two college semesters and totaling nine months, adhered to a budget allocation of approximately \$500. Major milestones were achieved through meticulous planning and execution, encompassing design and implementation phases, further subdivided into research, component sourcing, component testing, and final integration. The resulting fully functional prototype, constructed from Oriented Strand Board (OSB), incorporates the aforementioned sensors, a microcontroller, lighting apparatus, and water management controls. The completion of a fully operational prototype was accomplished early in the project timeline, allowing for the cultivation of basic crops to vividly demonstrate the efficacy and functionality of the design.

\comment{


% Dedication (Optional)
\section*{Dedication}
\addcontentsline{toc}{section}{Dedication}
\lipsum[1] % Replace with your dedication text


}

\comment {


% Acknowledgment (Optional)
\section*{Acknowledgment}
\addcontentsline{toc}{section}{Acknowledgment}
\lipsum[1] % Replace with your acknowledgment text

}

% Narrative Sections (Example structure)
\pagebreak
\section{Design, Methodology, and Implementation}
\noindent The hydroponics system was designed to address the challenges of food deserts by providing urban households with a sustainable and accessible means of growing fresh produce. The system's design methodology focused on integrating IoT capabilities, real-time monitoring, and community engagement features to enhance user experience and foster a sense of community among users. The implementation process involved sourcing components, designing the circuit, testing individual components, and integrating them into a functional system. The resulting hydroponics system comprises multiple sensors, a microcontroller, a water pump, and a UV lighting system, all working together to create an automated growing environment. The system's web application serves as a central hub for users to monitor plant health metrics, share insights, and exchange growing tips, enhancing the overall user experience. The project's successful completion demonstrates the feasibility of using technology to address food insecurity in urban areas and promote community-driven solutions to social challenges.

\subsection{Circuit Design}
\noindent

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Schematic.jpg}
    \caption{Circuit Schematic Overview}
    \label{fig:Schematic_Full}
\end{figure}

\noindent The hydroponics system's circuit design was specially crafted to ensure the seamless integration of its diverse components. These include multiple sensors, a microcontroller, a water pump, and a UV lighting system, each fulfilling a distinct role within the automated hydroponic framework. The design facilitates real-time monitoring of environmental conditions, nutrient levels, and plant health metrics, empowering users to optimize growth conditions and ensure robust crop development.
\newline
\newline
\noindent Comprehensive sensor integration encompasses temperature, humidity, light intensity, and water pH, enabling thorough data collection crucial for plant growth assessment. The microcontroller acts as the system's core, gathering sensor data, managing component operations, and supporting user interaction through a web interface. Essential components like the water pump and UV lighting system play vital roles in sustaining optimal growth conditions by ensuring adequate hydration and nutrient distribution.
\newline
\newline
\noindent The circuit design was meticulously planned to accommodate diverse power demands, establish effective communication protocols between sensors and the microcontroller, and enable seamless data exchange for real-time monitoring and control. This systematic approach resulted in a fully operational automated growing environment. The resulting circuit configuration forms a sturdy foundation for monitoring and managing key parameters essential for successful plant cultivation, allowing users to foster healthy crops with minimal manual intervention.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Schematic_With_TerminalBlocks.png}
    \caption{Circuit Schematic Designed with Terminal Blocks}
    \label{fig:Schem_TerminalBlocks}
\end{figure}
\noindent In the final month of the project's development, a PCB was designed to house the system's components, providing a compact and organized layout that enhances reliability and ease of maintenance. In order to connect the sensors placed at various distances around the housing, terminal blocks were used to extend the connections. The KiCad PCB designer required that the schematic include these screw terminals to ensure that all nets and wires were connected correctly. The updated schematic (\ref{fig:Schem_TerminalBlocks}) was then used to generate the Gerber files for manufacturing the PCB.


\subsection{Component Selection}
\noindent 1. \textbf{Microcontroller}
\begin{itemize}
    \item Raspberry Pi Pico W
\end{itemize}

\noindent 2. \textbf{Water Pump}
\begin{itemize}
    \item CrocSee 12VDC Diaphragm Pump
\end{itemize}

\noindent 3. \textbf{Power Supply Unit (PSU)} 
\begin{itemize}
    \item BMOUO 12V AC-to-DC Power Supply 
    \item FILSHU 10A 250V Power Socket Inlet Switch
\end{itemize}

\noindent 4. \textbf{Buck Converter}
\begin{itemize}
    \item DORHEA C120503 12V to 5V DC Converter
\end{itemize}

\noindent 5. \textbf{Sensors}
   \begin{itemize}
   \item Four DHT22 Sensors
   \item LTR-390UV-01 Light Sensor
   \item HC-SR04 ultrasonic sensor
   \item PH-4502C analog pH sensor
   \end{itemize}

\noindent 6. \textbf{Additional Circuit Parts}
   \begin{itemize}
   \item Flyback diode (1N4001RLGOSCT-ND)
   \item 220µF Capacitor (16ZLH220MEFCT16.3X11)
   \item Two N-Channel MOSFET (IRLZ34NPBF-ND)
   \item 8:1 MUX (SN74LS151N)
   \item 2.42" SSD1309 OLED display
   \item 60W full spectrum grow lights
   \item 18 AWG wire
   \item 22 AWG wire
   \end{itemize}

\subsection{Circuit Power Supply Design}
\noindent A 12V30A power supply unit (PSU) was selected to provide the necessary power for the hydroponics system. The PSU was chosen for its high current capacity, ensuring that all system components receive adequate power for optimal performance. The PSU is connected to a FILSHU 10A 250V power socket inlet switch, allowing for easy power management and control. The power supply unit is responsible for delivering the required voltage and current to the system's components, ensuring reliable operation and consistent performance. The PSU's high current capacity enables it to power multiple devices simultaneously, supporting the system's diverse functionalities and ensuring robust operation under varying load conditions.
\newline
\newline
\noindent Connected to the PSU is a DORHEA C120503 12V to 5V DC converter, which steps down the voltage to 5V for powering the Raspberry Pi Pico W microcontroller and various 5V sensors. The DC converter is essential for providing the microcontroller with the appropriate voltage level, ensuring stable operation and preventing damage due to overvoltage. The converter's efficient design and reliable performance make it an ideal choice for powering the microcontroller, enabling seamless integration into the hydroponics system. By converting the 12V input voltage to 5V, the DC converter ensures compatibility with the microcontroller's operating specifications, facilitating reliable communication and control of the system's components.
\newline
\newline
\noindent The inclusion of a 220uF capacitor \cite{ref_capacitor} in the circuit plays a critical role in maintaining the stability and integrity of the power supply, particularly given the dynamic nature of the loads present. This capacitor acts primarily as a decoupling device, providing voltage smoothing to mitigate fluctuations attributable to transient changes in the load, such as those occurring during the activation or deactivation of the motor, or the variable current demands of the LED array. It serves to absorb and release electrical energy, thereby ensuring a consistent voltage supply despite abrupt variations. Furthermore, the capacitor contributes to noise reduction by filtering out electrical interference generated by the motor and the pulsating operation of the LEDs, preserving other sensitive components from potential disruptions. Notably, the buck converter, which is susceptible to input voltage irregularities, benefits from the presence of the capacitor that acts as a buffer against voltage spikes. Moreover, the capacitor enhances the power supply's transient response, promptly supplying current during sudden demand surges, allowing the power supply to adapt effectively to the changing load requirements. This preventive measure ensures both the longevity and performance of the circuit components are optimized, and the risk of malfunctions is minimized.

\subsection{LED Control Circuit}
\noindent In the development of the LED control system, a low-side switching configuration was implemented using the IRLZ34N N-channel MOSFET. This configuration effectively allows the modulation of a 12V LED strip via signals originating from a Raspberry Pi Pico W microcontroller. The circuit is designed such that the source terminal of the IRLZ34N MOSFET is connected directly to the ground. The drain terminal is connected to the ground terminal of the LED strip, facilitating the control of the negative power line of the strip. The gate terminal of the MOSFET is interfaced with GPIO22 on the Raspberry Pi Pico W, enabling digital control of the LED strip’s operational state. The positive terminal of the LED strip is connected to a 12V power supply, ensuring the provision of the necessary driving voltage for the LEDs.
\newline
\newline
\noindent The IRLZ34N MOSFET \cite{ref_mosfet} operates based on the principles of semiconductor physics concerning the movement of electrons and the manipulation of charge carriers within the device. As an N-channel MOSFET, the primary charge carriers are electrons, which are more mobile than holes. The MOSFET is constructed with a channel between the source and the drain, made of N-type semiconductor material. When a positive voltage is applied to the gate relative to the source, it creates an electric field that induces a conduction channel in the underlying silicon structure. This channel allows electrons to flow from the source to the drain when the gate voltage exceeds a certain threshold, thereby completing the circuit and allowing current to flow through the LED strip.
\newline
\newline
\noindent The effectiveness of this setup is derived from the MOSFET's ability to act as a switch controlled by the gate voltage. With no voltage on the gate, the channel remains non-conductive; hence, the circuit is open and no current flows through the LED strip. Application of a sufficient voltage (approximately 3.3V from the Pico W GPIO) to the gate allows for the formation of the conductive channel, thus closing the circuit and enabling current flow.
\newline
\newline
The circuit's functionality was verified through a series of tests where the GPIO22 output was alternated between high and low states, corresponding to turning the LED strip on and off, respectively. These tests confirmed that the circuit performed as expected, with the MOSFET effectively controlling the connection between the LED strip and ground based on the GPIO signal. During testing, it was observed that the immediate activation of the LEDs upon application of the 12V supply was mitigated by ensuring correct MOSFET wiring and operation as described. Measurements of voltage levels at the gate, source, and drain were consistent with theoretical expectations, affirming the accuracy of the circuit design and the reliability of the components used.
\newline
\newline
The implemented design effectively demonstrates the utility of using an N-channel MOSFET for controlling high-power devices like LED strips with low-voltage digital signals from microcontrollers. This configuration not only provides efficient switching capabilities but also simplifies the interfacing between high and low-voltage systems in embedded applications. Further optimization of the circuit could involve the integration of additional control features such as dimming and flashing, which could be achieved by implementing PWM (Pulse Width Modulation) techniques through the Raspberry Pi Pico W.

\subsection{Motor Control Circuit}
\noindent The motor control circuit is similar to the LED control circuit, with the primary difference being the use of a CrocSee 12VDC diaphragm pump as the load. The CrocSee pump is a high-quality diaphragm pump designed for hydroponic systems, aquariums, and other applications requiring water circulation. The pump operates on a 12V DC power supply and is controlled by a Raspberry Pi Pico W microcontroller through an IRLZ34N N-channel MOSFET. The circuit configuration is based on a low-side switching design, allowing the microcontroller to modulate the pump's operational state by controlling the negative power line.
\newline
\newline
\noindent A 1N4001RLGOSCT diode \cite{ref_diode} is used in this circuit as a flyback diode to protect the MOSFET from voltage spikes generated by the pump's inductive load. The flyback diode is reverse-biased during normal operation, allowing current to flow through the pump. When the pump is turned off, the diode becomes forward-biased, providing a path for the voltage spike to dissipate harmlessly.
\newline
\newline
\noindent This circuit is controlled via GPIO21 on the Raspberry Pi Pico W, which is connected to the gate terminal of the IRLZ34N MOSFET. The source terminal of the MOSFET is connected to ground, while the drain terminal is connected to the ground terminal of the CrocSee pump. The positive terminal of the pump is connected to the 12V power supply, ensuring the necessary driving voltage for the pump's operation. By modulating the GPIO21 output between high and low states, the microcontroller can control the pump's operational state, enabling water circulation within the hydroponic system. 
\newline
\newline
\noindent Some pumps can change direction by reversing the polarity of the power supply, but the CrocSee pump used in this circuit operates in a single direction. The pump's operational state can be controlled by turning it on and off as needed to maintain optimal water circulation within the hydroponic system. The circuit's functionality was verified through a series of tests, confirming that the pump could be controlled effectively using the Raspberry Pi Pico W microcontroller. The flyback diode successfully protected the MOSFET from voltage spikes generated by the pump's inductive load, ensuring the circuit's reliability and longevity.

\subsection{Component Testing}
\subsubsection{BMOUO 12V AC-to-DC Power Supply}
\noindent The 12V30A power supply unit (PSU) was tested to verify its output voltage and current ratings. The PSU was connected to a digital multimeter to measure the output voltage and current under various load conditions. The voltage and current readings were compared to the manufacturer's specifications to ensure that the PSU was operating within the specified range. The test results confirmed that the PSU was delivering the required 12V voltage, making it suitable for powering the hydroponics system. The PSU's stable output voltage and current ratings ensure reliable operation of the system's components, providing the necessary power for optimal performance.
\subsubsection{DORHEA C120503 12V to 5V DC Converter}
\noindent The DORHEA C120503 12V to 5V DC converter was tested to verify its voltage conversion capabilities and efficiency. The converter was connected to a 12V power supply and a digital multimeter to measure the output voltage and current. The voltage and current readings were compared to the manufacturer's specifications to ensure that the converter was operating within the specified range. The test results confirmed that the converter was converting the 12V input voltage to 5V, making it suitable for powering the Raspberry Pi Pico W microcontroller and other 5V sensors. The converter's efficient voltage conversion and stable output ensure reliable operation of the microcontroller and other components, facilitating seamless integration into the hydroponics system. The test was repeated twice: first with the lab DC power supply and then with the PSU to ensure that the converter was functioning correctly under different load conditions.
\subsubsection{FILSHU 10A 250V Power Socket Inlet Switch}
\noindent The FILSHU 10A 250V power socket inlet switch was tested to verify its functionality and safety features. The switch was connected to the 12V30A power supply and a digital multimeter was connected to the power supply. The switch was then toggled on and off to verify that it could control the power supply's output. The test results confirmed that the switch was functioning correctly, allowing for easy power management and control of the hydroponics system. The switch's safety features and robust construction ensure reliable operation and user-friendly control of the system's power supply. It was found that it takes roughly 10 seconds from switching the inlet switch off until the power fully dissipated from the PSU.
\subsubsection{Raspberry Pi Pico W}
\noindent The Raspberry Pi Pico W \cite{ref_pico_w} had to undergo extensive testing to ensure that it was functioning correctly and could handle the demands of the hydroponics system. The Pico was tested by connecting it to a computer via micro-USB and running a series of test scripts to verify its GPIO, ADC, and I2C functionality. The onboard temperature sensors were not functioning correctly, but this was not concerning because external DHT22 sensors were already incorporated into the system. The Pico was also tested with the OLED display to verify that it could communicate with the display and output data correctly. The test results confirmed that the Pico was functioning as expected, providing the necessary processing power and I/O capabilities for the hydroponics system. The Pico's compact size and low power consumption make it an ideal choice for embedded applications, ensuring efficient operation and reliable performance.
\newline
\newline
\noindent The I2C and UART communication protocols were tested using the Pico's GPIO pins. The I2C protocol was tested by connecting the Pico to an OLED display and running a MicroPython script to display text on the screen. The UART protocol was tested by connecting the Pico to a computer via USB and running a script to send and receive data over the serial connection. The tests confirmed that the Pico's communication protocols were functioning correctly, enabling seamless data exchange between the microcontroller and external devices. The Pico's versatile communication capabilities make it well-suited for interfacing with a wide range of sensors and peripherals, enhancing the system's functionality and flexibility.
\subsubsection{DHT22 Temperature and Humidity Sensor}
\noindent The DHT22 temperature and humidity sensor was tested to verify its accuracy and reliability in measuring environmental conditions. The sensor was connected to the Raspberry Pi Pico W microcontroller, and a MicroPython script was run to read the temperature and humidity values. The sensor was placed in various environments with known temperature and humidity levels to compare the readings and assess the sensor's performance. Boveda humidity control packets \cite{ref_boveda} were used to verify the humidity readings when in an enclosed space with controlled humidity. The test results confirmed that the DHT22 sensor was accurate and reliable in measuring temperature and humidity, providing valuable data for monitoring the hydroponics system's growing environment. The sensor's stable performance and consistent readings ensure precise monitoring of environmental conditions, enabling users to optimize growth conditions and ensure healthy plant development.
\subsubsection{LTR-390UV-01 ALS + UV Sensor}
\noindent The LTR-390UV-01 UV \cite{ref_ltr390} sensor was tested to verify its accuracy and reliability in measuring UV light intensity. The sensor was connected to the Raspberry Pi Pico W microcontroller, and a MicroPython script \cite{ref_uvforum} was run to read the raw UV light intensity values. The sensor was placed in ambient room lighting and then under dedicated UV LEDs to compare the readings and assess the sensor's performance. The sensor was not sensitive enough to detect any UV light from a source more than a few inches away, but after increasing the gain to the maximum value it supported (\ref{appendix:ltr390}) the sensor was able to detect the UV light from the LEDs. The test results confirmed that the LTR-390UV-01 sensor was accurate and reliable in measuring UV light intensity, providing valuable data for monitoring the hydroponics system's UV lighting system. The sensor's stable performance and consistent readings ensure precise monitoring of UV light levels, enabling users to optimize growth conditions and ensure healthy plant development.
\subsubsection{CrocSee 12VDC Diaphragm Pump}
\noindent The CrocSee 12VDC diaphragm pump \cite{ref_crocsee} was not the original pump selection for this sytem. The original water pump, a Gikfun 12V DC dosing pump with peristaltic dosing head \cite{ref_gikfun} was used. This original pump, however, sustained water damage and would no longer function. When it was functional, the flow rate was not sufficient for the hydroponics system. The CrocSee pump was selected as a replacement due to its higher flow rate and compatibility with the system's 12V power supply. The pump was tested to verify its flow rate and operational performance in circulating water within the hydroponics system. The pump was first connected directly to the 12V power supply when both inlet/outlet tubes were submerged in a container of water. Upon powering the pump, the flow rate was observed and deemed sufficient. The pump was then connected to the Raspberry Pi Pico W microcontroller through an IRLZ34N MOSFET to enable digital control of the pump's operational state. The pump was tested with a MicroPython script to turn it on and off, verifying that the pump could be controlled effectively using the microcontroller. The test results confirmed that the CrocSee pump was suitable for circulating water within the hydroponics system, providing the necessary flow rate and operational reliability for optimal plant growth. This test also served as the basis for the IRLZ34N MOSFET test, which was successful in controlling the pump's operational state.
\subsubsection{IRLZ34NPBF MOSFET}
\noindent The IRLZ34NPBF MOSFET was selected due to its high drain-to-source voltage rating at 55V and low on-resistance (\ref{appendix:mosfet}). The MOSFET was tested to verify its switching capabilities and operational performance in controlling high-power devices like the CrocSee 12VDC diaphragm pump. The MOSFET was connected to the Raspberry Pi Pico W microcontroller through a 220µF capacitor and a 1N4001RLGOSCT flyback diode to protect the MOSFET from voltage spikes generated by the pump's inductive load. The MOSFET was then tested with a MicroPython script to turn the pump on and off, verifying that the MOSFET could control the pump's operational state effectively. The test results confirmed that the IRLZ34NPBF MOSFET was suitable for controlling high-power devices like the CrocSee pump, providing reliable switching capabilities and robust performance in the hydroponics system. The MOSFET's low on-resistance and high voltage rating ensure efficient operation and safe control of the pump, enabling precise water circulation within the system. Each MOSFET would be used as a low-side switch to control the pump's and LED's respective operational states, allowing for digital control of the loads' power connections.
\newline
\newline
\noindent Low-side switching using an IRLZ34N MOSFET involves connecting the source terminal to ground and the drain terminal to the load, with the other side of the load linked to a power supply's positive terminal. This configuration allows for straightforward control of the MOSFET by applying a voltage to the gate relative to its source. When a sufficient gate-to-source voltage is provided—typically around 2V for the IRLZ34N—the MOSFET conducts, allowing current to flow from the power supply through the load and into the drain, activating the load. Deactivation occurs when the voltage is removed from the gate, stopping current flow and thus powering down the load. This method is favored for its simplicity and cost-effectiveness, requiring fewer components and less complex drive circuitry compared to high-side switching. However, it is crucial to address potential ground reference issues and manage voltage spikes from inductive loads with protective components like flyback diodes to ensure robust operation.
\subsubsection{1N4001RLGOSCT-ND Flyback Diode}
\noindent The 1N4001RLGOSCT-ND \cite{ref_diode} diode was intended to be placed in reverse-bias across the CrocSee pump to protect the IRLZ34N MOSFET from voltage spikes generated by the pump's inductive load. The first attempt at testing the diode revealed that it was accidentally placed in forward-bias, causing the diode to burn out. A new, identical diode was then correctly placed in reverse-bias across the pump, and the test was repeated. The test results confirmed that the diode was functioning correctly, providing a path for the voltage spike generated by the pump's inductive load to dissipate harmlessly. The diode's reverse-bias configuration ensures that it remains non-conductive during normal operation, allowing current to flow through the pump. When the pump is turned off, the diode becomes forward-biased, providing a path for the voltage spike to dissipate safely, protecting the MOSFET, and ensuring the circuit's longevity. The diode's protective function safeguards the MOSFET from potential damage due to voltage spikes, ensuring reliable operation and robust performance of the hydroponics system.
\subsubsection{74LS151N 8:1 MUX}
\noindent The multiplexer \cite{ref_mux} was tested by connecting it to the ADC0 pin on the Raspberry Pi Pico W and using the GND, 3.3V, and 5V outputs from the Pico as known input voltages. The multiplexer was then used to switch between these inputs and output the selected voltage to the ADC0 pin. The output was then read using a MicroPython script (\ref{appendix:muxTest}) to verify that the multiplexer was functioning correctly. The test results confirmed that the 74LS151N 8:1 MUX was operating as expected, allowing for the selection of different input voltages and outputting the desired voltage to the ADC0 pin.
\newline
\newline
\noindent Unfortunately, during the final few weeks before the culmination of the project, the D0 and VCC pins on the MUX broke off, rendering the multiplexer unusable. This issue was identified during the final integration phase, and the decision was made to proceed without the multiplexer. This freed up GPIO pins that were originally used for select, enable, and the data line which were now replaced with the data lines of the sensors directly. 
\subsubsection{60W Full Spectrum Grow Lights}
\noindent The 60W full spectrum grow light LED strips \cite{ref_growled} are rated for 12V5A producing 60 Watts of power. This is a significant upgrade from the originally purchased LED strips \cite{ref_oldled} that were only rated for 5V2A. The purchasing of the original LEDs was an oversight because the power supply was rated for 12V, and the LEDs were rated for 5V. The new LEDs were tested by connecting them directly to a DC power supply and observing the light output and current usage. The test results confirmed that the LEDs were functioning correctly, providing the necessary full spectrum light for plant growth. The LEDs were then connected to the Raspberry Pi Pico W microcontroller through an IRLZ34N MOSFET to enable digital control of the LED strip's operational state. The LEDs were tested with a MicroPython script to turn them on and off, verifying that the MOSFET could control the LED strip's operational state effectively. The test results confirmed that the 60W full spectrum grow lights were suitable for providing the necessary light intensity for plant growth, enabling optimal photosynthesis and healthy plant development. The LEDs' high power output and full spectrum light coverage ensure robust growth conditions and promote healthy plant development within the hydroponics system. The difference in output is noticeable when comparing the two LED strips (\ref{fig:LED_Compare}).
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/led_compare.JPG}
    \caption{60W Full Spectrum LEDs (left) vs. 10W UV EDs (right)}
    \label{fig:LED_Compare}
\end{figure}
\subsubsection{pH Sensor - PH4502C}
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \textbf{pH} & \textbf{Voltage [V]} \\
        \hline
        4 & 3.071\\
        \hline
        7 & 2.535\\
        \hline
        10 & 2.066\\
        \hline
    \end{tabular}
    \caption{PH4502C pH to Voltage Conversion}
    \label{tab:PH4502C}
\end{table}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/ph_from_amazon.jpg}
    \caption{PH4502C pH Sensor \cite{ref_ph_amazon}}
    \label{fig:PH4502C}
\end{figure}
\noindent The PH4502C \cite{ref_phsensor} is designed to output the following voltages shown in Table \ref{tab:PH4502C}.
This data was provided by the manufacturer and was used to calibrate the pH sensor. An extensive calibration process was conducted for the PH4502C sensor module to ensure accurate pH readings. The sensor, equipped with two potentiometers for offset and slope adjustments, was designed to output a voltage correlating to the detected pH level, with a specified range of 0-5V.
\newline
\newline
\noindent Initially, difficulties were encountered in the calibration process due to output voltage readings exceeding the safe input range of the Raspberry Pi Pico’s analog-to-digital converter (ADC). A voltage divider was implemented to attenuate the sensor's voltage output. Subsequent readings from the sensor module were consistently registering maximum ADC values, indicative of an over-voltage condition. It was concluded that the direct output from the sensor was unsuitable for direct interfacing with the Pico’s ADC.
Following the integration of a voltage divider into the circuit, the output was reduced to acceptable levels within the Pico's ADC range of 0-3.3V (\ref{fig:ph_voltage}). However, the initial calibration attempt, while using the voltage divider, produced a reading that did not align with the standard pH buffer solution. Consequently, the calibration process was refined by removing the voltage divider and reading the output directly from the sensor module (\ref{fig:ph_test_full}), which resulted in a more stable and accurate voltage reading.
\newline
\newline
\noindent The offset potentiometer was then carefully adjusted while the sensor was immersed in a pH 7 buffer solution. The voltage was monitored using a multimeter, and the potentiometer was tuned until the output voltage closely matched the expected 2.51V as indicated on the product page for a pH 7 solution. This calibration point was further verified through a MicroPython script, which confirmed a pH reading of 7, correlating to the observed voltage of 2.5V. Finally, the pH was tested using litmus strips (\ref{fig:ph_litmus}) to verify the sensor's accuracy in detecting the pH level of the solution. The sensor was deemed accurate and reliable in measuring pH levels, providing valuable data for monitoring the hydroponics system's nutrient solution. The sensor's stable performance and consistent readings ensure precise monitoring of the nutrient solution's pH, enabling users to optimize nutrient levels and ensure healthy plant growth.
\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/ph_test_full.JPG}
        \caption{pH Sensor Test Setup}
        \label{fig:ph_test_full}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/ph_litmus.JPG}
        \caption{Litmus Strip Verification}
        \label{fig:ph_litmus}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/ph_voltage.JPG}
        \caption{2.5V Voltage Verification}
        \label{fig:ph_voltage}
    \end{subfigure}
    \caption{PH4502C pH Sensor Testing}
    \label{fig:phTestingComposite}
\end{figure}

\noindent An observation was made during the calibration that a red LED indicator on the sensor module was activated when the voltage dropped below 4V. It was inferred that this LED served as an indicator for out-of-range voltage conditions. The sensor was adjusted to maintain the output voltage above this threshold to prevent the activation of the LED indicator.
Once the sensor output was adjusted to the correct voltage for a pH 7 solution, the calibration was deemed successful. The calibration state was documented as stable, and the expectation was set that, barring any significant handling or environmental changes, recalibration would not be necessary before each use. 

\subsection{Printed Circuit Board Design}
\noindent The hydroponics system is powered by a 12V30A power supply with a maximum current draw of 5A. Temporary prototyping solutions such as a solderless breadboard were used to test the system's functionality. However, to ensure long-term reliability and ease of maintenance, a custom-designed printed circuit board (PCB) was developed to house the system's components. The PCB design process involved creating a schematic diagram, laying out the components, routing the traces, and generating the Gerber files for manufacturing. The PCB design was meticulously crafted to accommodate the system's sensors, microcontroller, motor control circuit, and power supply connections. The resulting PCB design provides a compact and organized layout that simplifies the assembly process and enhances the system's overall reliability.
\newline
\newline
\noindent The schematic and PCB were designed using free open-source software, KiCad. KiCad is a powerful EDA (Electronic Design Automation) tool that offers a comprehensive suite of features for designing schematics, laying out PCBs, and generating manufacturing files. The schematic design process involved creating symbols for each component, connecting the components with wires, and adding labels for easy identification. The schematic served as the foundation for the PCB layout, guiding the placement of components and the routing of traces. The PCB layout was carefully planned to ensure optimal component placement, signal integrity, and thermal management. By organizing the components in a logical and compact manner, the PCB design maximizes space utilization and minimizes signal interference, resulting in a clean and efficient layout.
\newline
\newline
\noindent The PCB was milled in-house using an LPKF ProtoMat Circuit Board Plotter. The milling process involved loading a blank copper-clad board into the plotter, importing the Gerber files generated from KiCad, and executing the milling operation. The LPKF ProtoMat precisely etched the traces and cut out the board outline, resulting in a custom PCB ready for component assembly. The milled PCB was inspected for any defects or errors, and the components were soldered onto the board following the assembly guide. The completed PCB was then tested to verify its functionality and ensure that all components were properly connected. The material for the PCB was 1/2 oz FR4 copper-clad board, which provides excellent thermal conductivity and electrical insulation properties.
\newline
\newline
\noindent The current carrying capacity of a printed circuit board (PCB) trace can be estimated using the formula from IPC 2221 \cite{ref_ipc_2221}, which is given by:
\begin{equation}
    I = k \cdot A^{0.44} \cdot (\Delta T)^{0.725}
\end{equation}
where:
\begin{itemize}
    \item \(I\) is the maximum current in Amperes (A) that the trace can safely carry.
    \item \(A\) is the cross-sectional area of the trace in square millimeters (mm\(^2\)), which can be calculated as the product of the trace width and thickness.
    \item \(\Delta T\) is the temperature rise above ambient in degrees Celsius (°C) that is considered acceptable for the application.
    \item \(k\) is a constant that depends on the location of the trace on the PCB. It is 0.024 for internal traces or 0.048 for external traces.
\end{itemize}

\noindent According to the provided specifications, for a trace thickness of 18µm on an external layer, the required trace width calculated by the IPC 2221 formula to carry a current of 5A with a temperature rise of 10°C is approximately 211 mils. With this calculated, special trace widths were defined in KiCad to automatically make the 12V5A lines 215mil wide, the 5V lines 50mil wide, and the new default setting 20mil wide. This ensures that the PCB can safely carry the required current without overheating or causing damage to the components.
\newline
\newline
\noindent Multiple through-hole screw terminal blocks were used for the sensors, motor, and power connections to facilitate easy assembly and maintenance. The screw terminals provide a secure and reliable connection for the wires, allowing for quick installation and removal of components. This also allows for distanced connections to the PCB which enables the LEDs, DHT sensors, water pump, and power supply to be placed in different locations. These terminal blocks were strategically placed on the PCB to ensure optimal wiring organization and accessibility. The PCB design was meticulously crafted to accommodate the system's components and facilitate easy assembly and maintenance. The resulting PCB layout (\ref{fig:PCB_DESIGN}) provides a compact and organized configuration that enhances the system's reliability and ease of use.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/PCB_Screenshot.png}
    \caption{First Iteration PCB in KiCad}
    \label{fig:PCB_DESIGN}
\end{figure}
\noindent After successfully milling the PCB in-house, the components were soldered onto the board following the assembly guide. At this stage, a fatal design flaw was discovered in the PCB layout that prevented several components from being soldered correctly. Several terminal blocks had pads on both layers of the PCB, meaning that it would be nearly impossible to solder the components with such minimal clearance. Additionally, the LPKF ProtoMat Circuit Board Plotter could not make plated through holes, which would have allowed for the components to be soldered on both sides of the board. As such, vias were essentially useless in this design without manually filling them with solder.
\newline
\newline
\noindent These design flaws were identified during the assembly process and were rectified by redesigning the PCB layout (\ref{fig:PCB_DESIGN_V2}) to ensure that all components could be soldered correctly. Unfortunately, this setback meant that a compromise had to be made such that only the high-current components were soldered onto the now single-layer PCB. The remaining components were placed on a breadboard and connected to the PCB using jumper wires to ensure that the system could still be tested and demonstrated. The revised PCB layout was milled, and the high-current components were successfully soldered onto the board (\ref{fig:Assembled_PCB}). The system was then tested to verify its functionality and ensure that all components were properly connected. The revised PCB design successfully accommodated the system's components and facilitated easy assembly and maintenance, despite the initial design flaw. The secondary iteration of the PCB layout was meticulously crafted to ensure optimal wiring organization and accessibility, enhancing the system's reliability and ease of use.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/PCB_V2_KiCad.png}
    \caption{Second Iteration PCB in KiCad}
    \label{fig:PCB_DESIGN_V2}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/Assembled_PCB.jpg}
    \caption{Assembled High Current PCB}
    \label{fig:Assembled_PCB}
\end{figure}

\subsection{Physical Enclosure Construction}
\noindent The designed of the physical enclosure was inspired by the need for sufficient area to grow up to 6 plants, a discrete way to route wiring, and a way to protect the electronics from water damage. The first draft of the enclosure was freehand drawn (\ref{fig:freehand}) and then modeled in Fusion 360 (\ref{fig:blueprints}). 
\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/freehand_design.jpeg}
        \caption{Freehand Design}
        \label{fig:freehand}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.5\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/fusion_specs.png}
        \caption{Fusion360 Dimensioned Drawing}
        \label{fig:fusionSpecs}
    \end{subfigure}
    \caption{Physical Enclosure Design Blueprints}
    \label{fig:blueprints}
\end{figure}
\noindent The dimensioned design in Fusion 360 was rendered to provide a visual representation of the enclosure's layout and size (\ref{fig:renderings}). The enclosure was designed to house the hydroponics system's components, including the sensors, microcontroller, motor control circuit, and power supply. The enclosure features a top cover that can be removed for easy access to the system's components, allowing for maintenance and troubleshooting. The enclosure's dimensions were carefully chosen to accommodate the system's components while providing sufficient space for plant growth and water circulation. The enclosure's design ensures that the system's components are protected from water damage and environmental factors, ensuring reliable operation and longevity.
\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/fusion_front.png}
        \caption{Render: Front View}
        \label{fig:fusionfront}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/fusion_back.png}
        \caption{Render: Rear View}
        \label{fig:fusionrear}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/fusion_bottom.png}
        \caption{Render: Underside View}
        \label{fig:fusionbottom}
    \end{subfigure}
    \caption{3D Renderings of the Physical Enclosure}
    \label{fig:renderings}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{images/construction2.jpeg}
    \caption{Physical Enclosure Initial Construction}
    \label{fig:initialconstruction}
\end{figure}
\noindent Upon the finalization of the design and renderings, the physical construction took place. The physical structure (\ref{fig:initialconstruction}) was created from a 4"x8" unit of Oriented Strand Board (OSB). The OSB was cut to size using prior to purchasing and was then transported and finally assembled using and screws and furring strips. The design consisted of two boxes that sat on top of each other: the lower portion houses the reservoir and circuitry and the upper portion holds the plants and plant containers. The enclosure was then painted with a water-resistant sealant to protect the wood from moisture and environmental factors. The top cover was designed to be removable to allow for easy access to the system's components. The 1" diameter PVC used to support the roof was cut to size and attached to the enclosure using screws. The PVC was left uncovered to allow for easy access to the system's components and to allow for access holes to be drilled in the side to route the LED wires through. By hiding the DHT22 and LED strip wiring in the PVC pipes, the system's wiring was kept organized and out of sight, enhancing the enclosure's aesthetic appeal and functionality.

\subsection{Server Configuration}
\noindent The central server is configured to house the web application and manage the data 
from the hydroponics systems. The server runs on a Debian operating system. Debian is a popular and widely used Linux distribution known for its reliability and extensive package management system. Debian offers a wide range of software packages through its repositories. It is favored for server environments due to its reliability and security features, making it a suitable choice for hosting various web applications, services, and data management systems. The entire backend system sits in a 42U server rack (\ref{fig:serverrack}). The server rack is equipped with a UPS (Uninterruptible Power Supply) to ensure continuous operation in the event of power outages or fluctuations. The server is connected to the internet via a high-speed gigabit ethernet connection, providing reliable connectivity for remote access and data transfer.
\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.25\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/server_bare.jpeg}
        \caption{Empty Server Rack (Rear)}
        \label{fig:emptyrackrear}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.25\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/server_bare2.jpeg}
        \caption{Empty Server Rack (Side)}
        \label{fig:emptyrackside}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.25\textwidth}
        \centering
        \includegraphics[width=\textwidth]{images/serverrack.png}
        \caption{Active Server Rack (Front)}
        \label{fig:activerack}
    \end{subfigure}
    \caption{3D Renderings of the Physical Enclosure}
    \label{fig:serverrack}
\end{figure}
\noindent Running on the Debian host machine is a Flask server. Flask is a simple and flexible framework for building web applications using Python. It helps developers create websites by providing tools for handling web page requests, organizing URLs, and displaying content. In Flask, routes serve as mappings between specific URLs and Python functions, enabling the application to respond to different requests. You can define custom functions for each URL endpoint, allowing dynamic content generation based on user interactions. Using the \verb|@app.route()| decorator, you specify the URL pattern associated with a particular function. Dynamic URLs can include variable parts, passed as arguments to the associated function, facilitating personalized responses. Within these functions, you can implement logic to generate dynamic content, such as fetching data from databases or processing user inputs. This approach enables the creation of dynamic web applications where each URL endpoint serves specific functionalities, thus offering a tailored user experience.
\newline
\newline
\noindent To enhance network reliability and accessibility for remote services, the deployment and configuration of the No-IP Dynamic Update Client (DUC) were undertaken on the Debian-based system. No-IP is a dynamic DNS service that allows internet users to provide a fixed domain name to their dynamically changing IP address, thereby ensuring that the connection to the server remains uninterrupted despite changes in the network configuration. This is particularly useful for hosting servers, remote access, and other network services that require constant accessibility over the Internet. To integrate No-IP's DUC into the system's services for automatic startup and recovery, a systemd service unit file was meticulously crafted and deployed. This configuration specifies the execution of the No-IP DUC software as a background service, thereby enabling it to update DNS records automatically whenever the system's IP address changes. Through careful examination and troubleshooting of systemd service file settings, potential issues were identified and resolved, ensuring seamless operation. The implementation enhances the system's network reliability and facilitates uninterrupted remote access.
\newline
\newline
\noindent The remote server has two ports exposed to the internet, one for the web application and one for SSH. To reduce the risk of unauthorized access, the SSH port was changed from the default port 22 to a non-standard port. This simple security measure significantly reduces the number of unauthorized login attempts and enhances the system's overall security. The web application port was also changed to a nonstandard port to further reduce the risk of unauthorized access. In addition to altering the default ports for SSH and the web application, two additional security measures were implemented on the remote server: fail2ban and ufw.
\newline
\newline
\noindent Fail2ban is an intrusion prevention software framework that operates by monitoring log files for patterns indicating unsuccessful login attempts or other malicious activity. Upon detection of such patterns, fail2ban dynamically updates firewall rules to block the IP addresses associated with the detected activity. By effectively blocking malicious actors attempting unauthorized access, fail2ban enhances the server's security posture and mitigates the risk of successful brute-force attacks.
\newline
\newline
\noindent UFW, or Uncomplicated Firewall, is a front-end for managing firewall rules in Linux-based systems. It provides a user-friendly interface for configuring firewall settings and managing network traffic. UFW simplifies the process of creating and maintaining firewall rules, enabling administrators to define access policies based on specific criteria such as IP addresses, ports, and protocols. By leveraging UFW to enforce firewall rules, administrators can restrict access to services running on the server, thereby reducing the attack surface and enhancing overall security.
\newline
\newline
\noindent By combining the use of non-standard ports with fail2ban and UFW, the security posture of the remote server is significantly bolstered against unauthorized access attempts and potential malicious activity. These measures collectively contribute to mitigating the risks associated with operating services accessible over the Internet, safeguarding the confidentiality, integrity, and availability of the hosted resources.
\subsubsection{Flask Routes - User Interface}
\noindent The Flask application routes are defined to handle various URL endpoints and user interactions. Each route corresponds to a specific functionality within the web application, facilitating dynamic content generation and user engagement. The routes are structured to provide a seamless user experience, enabling users to interact with the hydroponics system, view sensor data, and access community-driven features. By defining custom routes, developers can create a tailored web application that meets the specific requirements of the hydroponics project.
In simple terms, a route is a URL pattern associated with a specific function in the Flask application. When a user navigates to a particular URL, the corresponding function is executed, generating the content displayed on the web page.
\newline
\newline
\noindent At the start, the routes were set up to only serve static HTML pages, not templates. This was done to ensure that the basic functionality of the server was working. Once the basic functionality was confirmed, the routes were updated to serve templates. The templates were created using HTML, CSS, Javascript, and Jinja2 templating engine. The Jinja2 templating engine allows for the dynamic generation of HTML content based on variables passed from the Flask application. This enables the creation of interactive web pages that can display real-time sensor data, user inputs, and other dynamic content.
\newline
\newline
\noindent The Flask application encompasses several web pages and routes, each designed to fulfill specific functionalities within the hydroponics management system. The homepage serves as the landing page of the application and acts as the entry point for users, providing links to login, account creation, and information about the hydroponics system. This page is delivered directly via Flask as a static HTML file.
\newline
\newline
\noindent The login route supports both GET and POST requests; GET serves the login form while POST processes the login data. It checks credentials against the credentials collection in MongoDB, utilizes Werkzeug for password verification, and manages session data for logged-in users. Similarly, the create account route manages the registration of new users and supports GET for serving the registration form and POST for processing and storing user data. It ensures usernames are unique, hashes passwords for security, and initializes user-specific entries in other MongoDB collections like settings, data, and messages.
\newline
\newline
\noindent The settings page allows users to adjust settings related to their hydroponics system through a Jinja2 template that dynamically generates a form based on current settings stored in MongoDB. Users can adjust parameters such as watering frequency and light duration through sliders, and form submission updates the user-specific settings in the database.
\newline
\newline
\noindent The friends page displays a list of friends or other users from which settings can be downloaded. It fetches friend information from the credentials collection and renders it using a Jinja2 template. Each friend entry includes a button to download settings, triggering a fetch request to a specific route that handles settings retrieval.
\newline
\newline
\noindent The forum page serves as a community platform where users can post discussions or read posts, backed by MongoDB to store posts. It dynamically renders content through a Jinja2 template, allowing users to interact by adding new posts or viewing existing discussions. The plants page displays real-time data from various sensors related to the user’s plants, fetching and displaying sensor data stored in the data collection of MongoDB. The page updates dynamically to reflect real-time conditions of the hydroponics environment.
\newline
\newline
\noindent Additional functional routes include a download settings route that allows users to download and apply another user's settings to their system and a save settings route that receives POST requests from the settings page to update user-specific settings in MongoDB. Each route and page within the Flask application is carefully crafted to interact seamlessly with the MongoDB backend, ensuring data consistency and providing a responsive user experience. The use of Jinja2 templates enables dynamic content generation, making the web interface adaptable to real-time changes and user interactions.
\newline
\newline
\begin{table}[H]
    \centering
    \renewcommand{\arraystretch}{1.25} % Adjust the cell padding
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Endpoint} & \textbf{Supported Methods}\\
        \hline
        / & GET \\
        \hline
        /create\_account & GET, POST \\
        \hline
        /login & GET, POST \\
        \hline
        /logout & GET \\
        \hline
        /plants & GET \\
        \hline
        /forum & GET \\
        \hline
        /add\_post & POST \\
        \hline
        /friends & GET \\
        \hline
        /save\_settings & POST \\
        \hline
        /settings & GET \\
        \hline
        /download\_settings/<friend\_id> & GET \\
        \hline
        /control\_panel & GET \\
        \hline
    \end{tabular}
    \caption{Available Website Endpoints}
    \label{tab:Main_Endpoints}
\end{table}
\subsubsection{Flask Routes - Application Programming Interface}
\noindent The Raspberry Pi Pico W microcontroller communicates with the server through an action-driven API, enabling data exchange and system control. The API routes are designed to handle requests from the microcontroller, process sensor data, and update the database with real-time information. By defining custom API routes, a structured communication protocol between the microcontroller and the server was established, facilitating seamless data transmission and system control.
\newline
\newline
\noindent The API is characterized as a functional API or an action-based API, distinct from a strictly RESTful architecture. Its design revolves around executing specific actions and accessing targeted functionalities within the application, encompassing tasks such as retrieving sensor data, updating settings, managing hardware IDs, and controlling manual overrides. Each API endpoint corresponds to a particular operation, such as retrieving settings or updating manual overrides, and ensures stateless communication, with every request containing sufficient information for independent processing by the server. JSON payloads are consistently structured in responses, complemented by appropriate HTTP status codes signaling request outcomes. The API's design prioritizes scalability and flexibility, enabling clients to interact with discrete functionalities without rigid coupling to underlying data structures or database schemas, thereby accommodating diverse application requirements.
\newline
\newline
\begin{table}[H]
    \centering
    \renewcommand{\arraystretch}{1.25} % Adjust the cell padding
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Endpoint} & \textbf{Supported Methods}\\
        \hline
        /api/test & GET \\
        \hline
        /api/get\_hardware\_id & GET \\
        \hline
        /api/set\_hardware\_id & GET \\
        \hline
        /api/update\_settings & GET \\
        \hline
        /api/get\_settings & GET \\
        \hline
        /api/get\_humidity\_data & GET \\
        \hline
        /api/get\_temp\_data & GET \\
        \hline
        /api/get\_uv\_data & GET \\
        \hline
        /api/get\_ph\_data & GET \\
        \hline
        /api/get\_tank\_data & GET \\
        \hline
        /api/get\_all\_data & GET \\
        \hline
        /api/get\_manual\_override & GET \\
        \hline
        /api/update\_manual\_override & POST \\
        \hline
        /api/update\_uv\_data & POST \\
        \hline
        /api/update\_ph\_data & POST \\
        \hline
        /api/update\_temp\_data & POST \\
        \hline
        /api/update\_humidity\_data & POST \\
        \hline
        /api/update\_tank\_data & POST \\
        \hline
        /api/update\_all\_sensors\_data & POST \\
        \hline
    \end{tabular}
    \caption{Available API Endpoints}
    \label{tab:API_Endpoints}
\end{table}

% Future Work
\pagebreak
\section{Future Work}
\noindent The most desirable improvement that could be made is the creation of a single PCB for all components in lieu of a small PCB and a breadboard at the same time. This would mean increased surface area on the PCB would could be used to include two more pumps. One pump would assist the drainage of water in the plant containers while the other pump could be used to mix a nutrient solution into the water tank. While the size of the PCB increases, a smaller physical enclosure could potentially attract a wider audience and allow for easier placement in a home. The addition of a nutrient pump would allow for the system to be more self-sufficient and require less maintenance.
\newline
\newline
\noindent Additionally, the website does not adhere to privacy laws such as GDPR. The website should be updated to include a privacy policy and terms of service. The website should also include a cookie consent banner to comply with the EU's cookie law. The website should also include a way for users to delete their account and all associated data. This would require the addition of a delete account route and the deletion of all associated data from the database. Also, for demonstration purposes, when a new user joins the website, they are automatically added to the friends list of the every other user. This was intended to showcase the forum and friends functionalities. This should be removed in a production environment and instead users should be able to add friends manually.
\newline
\newline
\noindent Finally, a .com domain should be purchased for the website. This would make the website more professional and easier to remember. The website should also be hosted on a cloud server such as AWS or Google Cloud. This would allow for more reliable uptime and faster load times. The website currently uses a self-signed SSL certificate. This should be replaced with a valid SSL certificate from a trusted certificate authority. This would ensure that all data transmitted between the user and the server is encrypted and secure.
% Conclusion
\section{Conclusion}
\noindent The Luli Hydroponics System is a comprehensive solution for growing plants without soil. The system integrates a variety of sensors, a microcontroller, and a web application to monitor and control the hydroponics environment. Designed to provide real-time data on pH, temperature, humidity, UV light, and water level, the LuLi system enables users to optimize their plant growth conditions. The Raspberry Pi Pico W microcontroller serves as the central processing unit, interfacing with the sensors and controlling the system's components. The microcontroller communicates with the central server through an API, enabling data exchange and system control. The server hosts a web application that allows users to monitor sensor data, adjust settings, and interact with other users through a community platform. The physical enclosure provides a secure and organized environment for the system's components, ensuring reliable operation and ease of maintenance. The system's modular design allows for future expansion and customization, enabling users to tailor the system to their specific needs. The Luli Hydroponics System represents a versatile and user-friendly solution for growing plants hydroponically, offering a comprehensive platform for plant cultivation and environmental monitoring.

% Appendices
\appendix
\pagebreak
\section{Software Appendix}
\subsection{Raspberry Pi Pico W MicroPython Code}
\subsubsection{Luli\_main.py}
\begin{pythoncode}[caption={Main MicroPython Code}]
    
from Luli_UV import LTR390
from Luli_Ultrasonic import WaterLevelSensor
from Luli_pH import PHSensor
from Luli_OLED import OLEDMenuDisplay
from Luli_DHT import DHT22Handler
from Luli_Networkhandler import NetworkHandler
from Luli_MotorLEDControl import MotorAndLEDControl
import machine
import Luli_CONFIG
import utime

MOTOR_LED_CONTROL = MotorAndLEDControl()

# Sensor Initialization
PH_SENSOR = PHSensor()
UV_SENSOR = LTR390()
TANK_SENSOR = WaterLevelSensor()
DHTS = DHT22Handler()


# External Hardware/Misc Initialization
OLED = OLEDMenuDisplay()
NETWORK = NetworkHandler(Luli_CONFIG.WIFI_SSID, Luli_CONFIG.WIFI_PASSWORD, Luli_CONFIG.SERVER_URL)

def log_error(e):
    with open('error_log.txt', 'a') as file:  # 'a' opens the file for appending
        timestamp = utime.localtime()  # Get the current time
        readable_timestamp = "{year}/{month}/{day} {hours}:{minutes}:{seconds}".format(
            year=timestamp[0], month=timestamp[1], day=timestamp[2],
            hours=timestamp[3], minutes=timestamp[4], seconds=timestamp[5]
        )
        file.write('{} - Error: {}\n'.format(readable_timestamp, e))

def sensor_uv_read():
    # Give the sensor some time to start
    utime.sleep(Luli_CONFIG.DELAY_UV_STARTUP)
    raw, uv_intensity = UV_SENSOR.get_uv_data()
    print("RAW: {}".format(raw))
    print("UV Intensity: {}uW/cm^2".format(uv_intensity))
    #return raw, uv_intensity
    return uv_intensity

def sensor_ph_read():
    ph_level = PH_SENSOR.get_ph()
    print("Current pH level:", ph_level)
    return ph_level

#def sensor_tank_calibrate():
#    TANK_SENSOR.calibrate_tank_full()
#    TANK_SENSOR.calibrate_tank_empty()

def sensor_tank_read():
    return TANK_SENSOR.get_water_level()
    

def sensor_temp_read():
    # Compute average temp of sensors 0 to 3
    total_temp = 0
    for i in range(4):
        # Average and convert to Fahrenheit
        temp = DHTS.get_temperature(i)
        num_DHTs = 4
        if temp is not None:
            total_temp += ((temp * 9/5) + 32)
        else:
            total_temp += 0
            num_DHTs = num_DHTs - 1
    if num_DHTs <= 1:
        num_DHTs = 1
    avg_temp = total_temp / num_DHTs
    print("Average temperature:", avg_temp)
    return avg_temp

def sensor_humidity_read():
    # Compute average humidity of sensors 0 to 3
    total_hum = 0
    num_DHTs = 4
    for i in range(4):
        hum = DHTS.get_humidity(i)
        if hum is not None:
            total_hum += DHTS.get_humidity(i)
            
        else:
            total_hum += 0
            num_DHTs = num_DHTs - 1
    if num_DHTs <= 1:
        num_DHTs = 1
    avg_hum = total_hum / num_DHTs
    print("Average humidity:", avg_hum)
    return avg_hum

def update_display(plant_name='Lettuce', planted_date='3/15/24', harvest_date='5/10/24', ph_param=None, temp_param=None, light_param=None, humidity_param=None, tank_param=None):
    ph = ph_param if ph_param is not None else sensor_ph_read()
    temp = temp_param if temp_param is not None else sensor_temp_read()
    light = light_param if light_param is not None else sensor_uv_read()
    humidity = humidity_param if humidity_param is not None else sensor_humidity_read()
    tank = tank_param if tank_param is not None else sensor_tank_read()

    OLED.print_sensor_data(ph=ph, temp=temp, light=light, humidity=humidity, tank=tank)
    utime.sleep(Luli_CONFIG.DELAY_OLED)
    OLED.print_plant_menu(plant_name=plant_name, planted_date=planted_date, harvest_date=harvest_date)
    utime.sleep(Luli_CONFIG.DELAY_OLED)

def send_all_data(ph_param=None, temp_param=None, light_param=None, humidity_param=None, tank_param=None):
    ph = ph_param if ph_param is not None else sensor_ph_read()
    temp = temp_param if temp_param is not None else sensor_temp_read()
    light = light_param if light_param is not None else sensor_uv_read()
    humidity = humidity_param if humidity_param is not None else sensor_humidity_read()
    tank = tank_param if tank_param is not None else sensor_tank_read()


    data = {
        "ph": ph,
        "temp": temp,
        "light": light,
        "humidity": humidity,
        "tank": tank
    }
    try:
        response = NETWORK.send_data(Luli_CONFIG.ENDPOINT_UPDATE_ALL_SENSOR_DATA, data)
    except Exception as e:
        print("Error sending all sensor data:", e)
        #log_error(e)
    return response

def send_data(data, data_label):
    response = None
    
    if data_label == 'ph':
        try:
            response = NETWORK.send_data(Luli_CONFIG.ENDPOINT_UPDATE_PH_DATA, data)
        except Exception as e:
            print("Error sending pH data:", e)
            #log_error(e)
    elif data_label == 'temp':
        try:
            response = NETWORK.send_data(Luli_CONFIG.ENDPOINT_UPDATE_TEMP_DATA, data)
        except Exception as e:
            print("Error sending temperature data:", e)
            #log_error(e)
    elif data_label == 'light':
        try:
            response = NETWORK.send_data(Luli_CONFIG.ENDPOINT_UPDATE_UV_DATA, data)
        except Exception as e:
            print("Error sending UV data:", e)
            #log_error(e)
    elif data_label == 'humidity':
        try:
            response = NETWORK.send_data(Luli_CONFIG.ENDPOINT_UPDATE_HUMIDITY_DATA, data)
        except Exception as e:
            print("Error sending humidity data:", e)
            #log_error(e)
    elif data_label == 'tank':
        try:
            response = NETWORK.send_data(Luli_CONFIG.ENDPOINT_UPDATE_TANK_DATA, data)
        except Exception as e:
            print("Error sending tank data:", e)
            #log_error(e)
    else:
        print("Invalid data label")

    # if response was successful, return True
    if response.status_code == 200:
        return True
    else:
        return False

def update_config(new_settings):
    #Luli_CONFIG.UV_READ_INTERVAL = int(new_settings.get('uv_read_interval', Luli_CONFIG.UV_READ_INTERVAL))
    #Luli_CONFIG.TEMP_HUMIDITY_READ_INTERVAL = int(new_settings.get('temp_humidity_read_interval', Luli_CONFIG.TEMP_HUMIDITY_READ_INTERVAL))
    Luli_CONFIG.DURATION_WATER_CYCLE = int(new_settings.get('pump_duration', Luli_CONFIG.DURATION_WATER_CYCLE)) or Luli_CONFIG.DURATION_WATER_CYCLE
    Luli_CONFIG.NEXT_WATER_CYCLE = int(new_settings.get('water_internval', Luli_CONFIG.NEXT_WATER_CYCLE)) or Luli_CONFIG.NEXT_WATER_CYCLE
    Luli_CONFIG.DURATION_LED_CYCLE = int(new_settings.get('led_duration', Luli_CONFIG.DURATION_LED_CYCLE)) or Luli_CONFIG.DURATION_LED_CYCLE
    print("Updated settings from server")


if __name__ == '__main__':
    # Projects Day Demo Timings
    # 1. Read UV Sensor Data every 2 minutes
    # 2. Read pH Sensor Data and tank level data after every water pump cycle
    # 3. Read Temperature and Humidity every 30 seconds


    MOTOR_LED_CONTROL.motor_off()
    MOTOR_LED_CONTROL.leds_on()

    try:
        # Start time
        start_time = utime.time()
        next_uv_time = start_time + Luli_CONFIG.UV_READ_INTERVAL
        next_temp_humidity_time = start_time + Luli_CONFIG.TEMP_HUMIDITY_READ_INTERVAL
        next_motor_start_time = start_time # Start motor on startup
        next_motor_stop_time = start_time + Luli_CONFIG.DURATION_WATER_CYCLE
        next_manual_override_check_time = start_time + Luli_CONFIG.MANUAL_OVERRIDE_CHECK_INTERVAL  # Setting up the next time to check for manual overrides
        next_settings_update_time = start_time + Luli_CONFIG.SETTINGS_UPDATE_INTERVAL
        
        temperature = None
        humidity = None
        ph = None
        tank = None
        uv = None

        # Assumes tank is full on startup
        TANK_SENSOR.calibrate_tank_full()

        while True:

            current_time = utime.time()
            
            
            # Start Water Cycle that reads pH and tank level
            if current_time >= next_motor_start_time:
                tank_level_percent = sensor_tank_read()  # Get the current water level percentage
                if tank_level_percent is not None and tank_level_percent > Luli_CONFIG.MINIMUM_WATER_LEVEL:
                    MOTOR_LED_CONTROL.motor_on()
                    next_motor_stop_time = current_time + Luli_CONFIG.DURATION_WATER_CYCLE  # Schedule to stop
                    next_motor_start_time = next_motor_stop_time + Luli_CONFIG.NEXT_WATER_CYCLE
                else:
                    print("Water level too low to start pump")
                    #next_motor_start_time = current_time + Luli_CONFIG.CHECK_WATER_LEVEL_INTERVAL  # Check again after some time
                    
            #print("CURRENT: ", current_time)
            #print("SToP TIME: ", next_motor_stop_time)
            if current_time >= next_motor_stop_time:
                MOTOR_LED_CONTROL.motor_off()
                print("MOTOR SHOULD BE OFF")
                ph = sensor_ph_read()
                tank = sensor_tank_read()  # Read again after pump off in case level has changed
                update_display(ph_param=ph, tank_param=tank)
                try:
                    send_data(ph, 'ph')
                    send_data(tank, 'tank')
                except Exception as e:
                    print("Error sending pH/tank data:", e)
                next_motor_start_time = current_time + Luli_CONFIG.NEXT_WATER_CYCLE  # Schedule next cycle

            # Check for manual override every 30 seconds
            if current_time >= next_manual_override_check_time:
                try:
                    # Check for manual override
                    override_commands = NETWORK.get_manual_override()
                    if override_commands:
                        print("Manual override commands received:", override_commands)
                        if 'motor' in override_commands:
                            if override_commands['motor'] == 'on':
                                MOTOR_LED_CONTROL.motor_on()
                            elif override_commands['motor'] == 'off':
                                MOTOR_LED_CONTROL.motor_off()
                        if 'leds' in override_commands:
                            if override_commands['leds'] == 'on':
                                MOTOR_LED_CONTROL.leds_on()
                            elif override_commands['leds'] == 'off':
                                MOTOR_LED_CONTROL.leds_off()
                        if 'read_light' in override_commands:
                            uv = sensor_uv_read()
                            update_display()
                            send_data(uv, 'light')
                        if 'read_temp' in override_commands:
                            temperature = sensor_temp_read()
                            update_display()
                            send_data(temperature, 'temp')
                        if 'read_humidity' in override_commands:
                            humidity = sensor_humidity_read()
                            update_display()
                            send_data(humidity, 'humidity')
                        if 'read_ph' in override_commands:
                            ph = sensor_ph_read()
                            update_display(ph_param=ph)
                            send_data(ph, 'ph')
                        if 'read_tank' in override_commands:
                            tank = sensor_tank_read()
                            update_display(tank_param=tank)
                            send_data(tank, 'tank')
                except Exception as e:
                    print("Error getting manual override:", e)
                    #log_error(e)
                
                # Update the next check time for manual overrides
                next_manual_override_check_time = current_time + Luli_CONFIG.MANUAL_OVERRIDE_CHECK_INTERVAL
            
            # Check for settings update every 2 minutes
            if current_time >= next_settings_update_time:
                try:
                    new_settings = NETWORK.fetch_and_update_settings()
                    if new_settings:
                        update_config(new_settings)
                    next_settings_update_time = current_time + Luli_CONFIG.SETTINGS_UPDATE_INTERVAL
                except Exception as e:
                    print("Error fetching settings:", e)
                    #log_error(e)

            # Read UV and update display every 120 seconds
            if current_time >= next_uv_time:
                uv = sensor_uv_read()
                update_display()
                try:
                    send_data(uv, 'light')
                except Exception as e:
                    print("Error sending UV data:", e)
                next_uv_time = current_time + Luli_CONFIG.UV_READ_INTERVAL  # Schedule next run

            # Read Temperature and Humidity every 30 seconds
            if current_time >= next_temp_humidity_time:
                temperature = sensor_temp_read()
                humidity = sensor_humidity_read()
                update_display()
                try:
                    send_data(temperature, 'temp')
                    send_data(humidity, 'humidity')
                except Exception as e:
                    print("Error sending temp/humidity data:", e)
                next_temp_humidity_time = current_time + Luli_CONFIG.TEMP_HUMIDITY_READ_INTERVAL # Schedule next run

            
            

            utime.sleep(0.1)  # Sleep for 100ms to reduce CPU usage

    except Exception as e:
        # SHUTDOWN ERROR CODE
        # Log the error
        log_error(e)
        print("Error:", e)
        MOTOR_LED_CONTROL.motor_off()
        for _ in range(3):
            MOTOR_LED_CONTROL.leds_off()
            utime.sleep(0.5)
            MOTOR_LED_CONTROL.leds_on()
            utime.sleep(0.5)
        MOTOR_LED_CONTROL.leds_off()
        machine.reset() # Reset the board if an error occurs

\end{pythoncode}
\subsubsection{Luli\_CONFIG.py}
\begin{pythoncode}[caption={Pico W Configuration File}, label={lst:config_micropython}]
# Luli Hydroponics Config File
# This file will define all necessary pins and timing constants for the Luli Hydroponics system

#####################
#   PIN SETTINGS    #
#####################
PIN_UV_SENSOR_SDA = 0
PIN_UV_SENSOR_SCL = 1

PIN_OLED_SCK = 10
PIN_OLED_MOSI = 11
PIN_OLED_CS = 13
PIN_OLED_RST = 14
PIN_OLED_DC = 15

PIN_ULTRASONIC_ECHO = 9
PIN_ULTRASONIC_TRIG = 17

PIN_DHT0 = 16
PIN_DHT1 = 18
PIN_DHT2 = 19
PIN_DHT3 = 20

PIN_MOTOR = 21
PIN_LED = 22
PIN_PH_SENSOR = 26




#########################
#   TIMING CONSTANTS    #
#########################
DELAY_OLED = 5 # seconds
DELAY_PH_RESPONSE = 50 # ms
DELAY_UV_STARTUP = 1 # seconds

TEMP_HUMIDITY_READ_INTERVAL = 30 # seconds
UV_READ_INTERVAL = 120 # seconds
MANUAL_OVERRIDE_CHECK_INTERVAL = 30 # seconds
SETTINGS_UPDATE_INTERVAL = 120 # seconds
DURATION_WATER_CYCLE = 60 # seconds
NEXT_WATER_CYCLE = 3600 # seconds
DURATION_LED_CYCLE = 3600 # seconds



#########################
#   NETWORK SETTINGS    #
#########################
WIFI_SSID = 'WIFI_NAME'
WIFI_PASSWORD = 'PASSWORD'
SERVER_URL = 'https://luli-hydroponics.ddns.net'



#########################
#   ENDPOINT SETTINGS   #
#########################
ENDPOINT_TEST = '/api/test'
ENDPOINT_GET_SETTINGS = '/api/get_settings'
ENDPOINT_SET_HARDWARE_ID = '/api/set_hardware_id'
ENDPOINT_UPDATE_SETTINGS = '/api/update_settings'
ENDPOINT_UPDATE_UV_DATA = '/api/update_uv_data'
ENDPOINT_UPDATE_PH_DATA = '/api/update_ph_data'
ENDPOINT_UPDATE_TEMP_DATA = '/api/update_temp_data'
ENDPOINT_UPDATE_HUMIDITY_DATA = '/api/update_humidity_data'
ENDPOINT_UPDATE_TANK_DATA = '/api/update_tank_data'
ENDPOINT_UPDATE_ALL_SENSOR_DATA = '/api/update_all_sensor_data'
ENDPOINT_MANUAL_OVERRIDE = '/api/get/manual_override'


######################
#   MISC CONSTANTS   #
######################
# https://optoelectronics.liteon.com/upload/download/DS86-2015-0004/LTR-390UV_Final_%20DS_V1%201.pdf
UVS_CONVERSION_FACTOR = 2300 # Conversion factor from the datasheet
VOLTAGE_AT_PH7 = 2.51
VOLTAGE_AT_PH4 = 3.03
MINIMUM_WATER_LEVEL = 20 # Minimum water level in the tank in percentage (%)
TANK_EMPTY_DISTANCE = 12 # Distance in cm when the tank is empty
\end{pythoncode}
\subsubsection{Luli\_DHT.py}
\begin{pythoncode}[caption={Pico W DHT22 Sensor Code}]
    import dht
    from machine import Pin
    import time
    import Luli_CONFIG
    
    class DHT22Handler:
        def __init__(self):
            # Initialize all DHT22 sensors on their respective pins
            self.sensors = [
                dht.DHT22(Pin(Luli_CONFIG.PIN_DHT0, Pin.IN, Pin.PULL_DOWN)),
                dht.DHT22(Pin(Luli_CONFIG.PIN_DHT1, Pin.IN, Pin.PULL_DOWN)),
                dht.DHT22(Pin(Luli_CONFIG.PIN_DHT2, Pin.IN, Pin.PULL_DOWN)),
                dht.DHT22(Pin(Luli_CONFIG.PIN_DHT3, Pin.IN, Pin.PULL_DOWN))
            ]
    
        def measure_all(self):
            # Attempt to measure from all sensors up to three times
            retry = 0
            while retry < 3:
                try:
                    for sensor in self.sensors:
                        sensor.measure()
                    return True
                except Exception as e:
                    print(".", end="")
                    retry += 1
                    time.sleep(0.5)
            return False
    
        def get_temperature(self, sensor_index):
            # Return the temperature from the specified sensor
            if self.measure_all():
                return self.sensors[sensor_index].temperature()
            else:
                print("Failed to read temperature after several attempts.")
                return None
    
        def get_humidity(self, sensor_index):
            # Return the humidity from the specified sensor
            if self.measure_all():
                return self.sensors[sensor_index].humidity()
            else:
                print("Failed to read humidity after several attempts.")
                return None
            
    def main():
        dht_handler = DHT22Handler()
        while True:
            print("Measuring.")
            for i in range(4):
                temp = dht_handler.get_temperature(i)
                hum = dht_handler.get_humidity(i)
                if temp is not None and hum is not None:
                    print(f"Sensor {i}: Temperature: {temp} C, Humidity: {hum} %")
            time.sleep(3)
    
    if __name__ == "__main__":
        main()
    
    
\end{pythoncode}
\subsubsection{Luli\_MotorLEDControl.py}
\begin{pythoncode}[caption={Pico W Low Side Switching MOSFET Control Code}]
    from machine import Pin
    import time
    import Luli_CONFIG
    
    class MotorAndLEDControl:
        def __init__(self, motor_pin=Luli_CONFIG.PIN_MOTOR, led_pin=Luli_CONFIG.PIN_LED):
            # Initialize motor and LED pins
            self.motor_gate = Pin(motor_pin, Pin.OUT)
            self.led_gate = Pin(led_pin, Pin.OUT)
    
        def motor_on(self):
            # Turn the motor on
            print("MOTOR ON")
            self.motor_gate.value(1)
    
        def motor_off(self):
            # Turn the motor off
            print("MOTOR OFF")
            self.motor_gate.value(0)
    
        def leds_on(self):
            # Turn the LED on
            print("LEDS ON")
            self.led_gate.value(1)
    
        def leds_off(self):
            # Turn the LED off
            print("LEDS OFF")
            self.led_gate.value(0)
    
    # Testing the class functionality
    if __name__ == "__main__":
        control = MotorAndLEDControl()
    
        # Testing Motor Control
        control.motor_off()
        control.leds_off()
        time.sleep(3)
        control.motor_on()
        time.sleep(45)
        control.motor_off()
        time.sleep(5)
    
        # Testing LED Control
        while True:
            control.led_on()
            time.sleep(1)
            control.led_off()
            time.sleep(1)
    
    
\end{pythoncode}
\subsubsection{Luli\_Networkhandler.py}
\begin{pythoncode}[caption={Pico W Network Handler Code}]
    import network
    import urequests as requests
    import ujson
    import machine
    import Luli_CONFIG
    class NetworkHandler:
        def get_hardware_id(self):
            # Get the unique hardware ID
            unique_id = machine.unique_id()
            # Convert ID bytes to hexadecimal string
            hex_string = "".join("{:02x}".format(byte) for byte in unique_id)
            print("Unique Hardware ID:", hex_string)
            return unique_id
        
    
        
        def __init__(self, ssid, password, base_url):
            self.ssid = Luli_CONFIG.WIFI_SSID
            self.password = Luli_CONFIG.WIFI_PASSWORD
            self.base_url = Luli_CONFIG.SERVER_URL
            self.wlan = network.WLAN(network.STA_IF)
            self.hardware_id = str(self.get_hardware_id())
    
        def connect_wifi(self):
            """Connects to WiFi using the SSID and password provided during initialization."""
            self.wlan.active(True)
            if not self.wlan.isconnected():
                print('Connecting to network...')
                self.wlan.connect(self.ssid, self.password)
                while not self.wlan.isconnected():
                    pass
            print('Network config:', self.wlan.ifconfig())
    
        def send_data(self, endpoint, data):
            """Sends data to a specified API endpoint using HTTP POST."""
            headers = {'Content-Type': 'application/json', 'X-Device-ID': self.hardware_id}
            try:
                response = requests.post(self.base_url + endpoint, data=ujson.dumps(data), headers=headers)
                print(response.text)
                # Free up memory once the request is complete
                if 'response' in locals():
                    response.close()
                return response
            except Exception as e:
                print("Failed to send data:", e)
                return None
            
        
        def get_manual_override(self):
            """Checks for manual override commands from the server using device-specific endpoint."""
            device_specific_endpoint = Luli_CONFIG.ENDPOINT_MANUAL_OVERRIDE + '/' + self.hardware_id
            try:
                response = requests.get(self.base_url + device_specific_endpoint)
                if response.status_code == 200:
                    commands = response.json()
                    return commands
                else:
                    print("Failed to get manual override, status code:", response.status_code)
                    return None
            except Exception as e:
                print("Failed to get manual override:", e)
                return None
            finally:
                if 'response' in locals():
                    response.close()
    
        def fetch_and_update_settings(self):
            headers = {'X-Device-ID': Luli_CONFIG.DEVICE_ID}
            try:
                response = requests.get(self.base_url + Luli_CONFIG.ENDPOINT_GET_SETTINGS, headers=headers)
                if response.status_code == 200:
                    new_settings = response.json()
                    return new_settings
                else:
                    print("Failed to fetch settings:", response.text)
            except Exception as e:
                print("Failed to fetch settings:", e)
                return None
            finally:
                if 'response' in locals():
                    response.close()
    
        
    
    if __name__ == '__main__':
        ssid = 'YourSSID'
        password = 'YourPassword'
        base_url = 'http://yourapi.com'
        endpoint = '/api/update_all_sensor_data'
        sensor_data = {
            "temp": 23.5,
            "humidity": 45,
            "light": 300,
            "ph": 7.0,
            "tank": 80
        }
    
        network_handler = NetworkHandler(ssid, password, base_url)
        network_handler.connect_wifi()
        network_handler.send_data(endpoint, sensor_data)
    
    
\end{pythoncode}
\subsubsection{Luli\_OLED.py}
\begin{pythoncode}[caption={Pico W OLED Display Code}]
    from machine import Pin, SPI
    import ssd1306
    import time
    import Luli_CONFIG
    
    class OLEDMenuDisplay:
        def __init__(self):
            # SPI setup
            self.spi = SPI(1, baudrate=1000000, polarity=1, phase=1, bits=8, firstbit=SPI.MSB,
                           sck=Pin(Luli_CONFIG.PIN_OLED_SCK), mosi=Pin(Luli_CONFIG.PIN_OLED_MOSI))
            # Display setup
            self.cs = Pin(Luli_CONFIG.PIN_OLED_CS)   # Chip select
            self.dc = Pin(Luli_CONFIG.PIN_OLED_DC)   # Data/command
            self.rst = Pin(Luli_CONFIG.PIN_OLED_RST, Pin.OUT)   # Reset
            self.display = ssd1306.SSD1306_SPI(128, 64, self.spi, self.dc, self.rst, self.cs)
    
            self.display.poweron()
            self.display.show()
    
        def init_main_menu(self):
            self.display.fill(0)
            self.display.rect(0, 0, 10, 20, 1)
            self.display.rect(11, 0, 117, 20, 1)
            self.display.text('Sensor Data', 13, 5, 1)
    
            self.display.rect(0, 21, 10, 20, 1)
            self.display.rect(11, 21, 117, 20, 1)
            self.display.text('Cycle Info', 13, 25, 1)
            
            self.display.rect(0, 42, 10, 20, 1)
            self.display.rect(11, 42, 117, 20, 1)
            self.display.text('Plants', 13, 45, 1)
            self.display.show()
    
        def print_main_menu(self, select):
            self.display.fill(0)
            menu_highlight = 20 * select + select
            self.init_main_menu()
            self.display.fill_rect(0, menu_highlight, 10, 20, 1)
            self.display.show()
    
        def print_sensor_data(self, ph, temp, light, humidity, tank):
            self.display.fill(0)
            self.display.text('Tank: ' + str(tank), 0, 0, 1)
            self.display.text('pH: ' + str(ph), 0, 16, 1)
            self.display.text('Temp: ' + str(temp), 0, 27, 1)
            self.display.text('Light: ' + str(light), 0, 39, 1)
            self.display.text('Humidity: ' + str(humidity), 0, 51, 1)
            self.display.show()
    
        def print_plant_menu(self, plant_name='Spinach', planted_date='5/5/24', harvest_date='9/3/24'):
            self.display.fill(0)
            self.display.text('Plants', 0, 0, 1)
            self.display.text(f'Plant: {plant_name}', 0, 16, 1)
            self.display.text(f'Planted: {planted_date}', 0, 27, 1)
            self.display.text(f'Harvest: {harvest_date}', 0, 39, 1)
            self.display.show()
    
    def main():
        display = OLEDMenuDisplay()
        #display.init_main_menu()
        time.sleep(1)
    
        # Loop through menu printing functions as an example
        while True:
            display.print_sensor_data(7.2, 22.5, 150, 45, 'Full')
            time.sleep(6)
            display.print_plant_menu('Tomatoes', '4/1/24', '6/28/24')
            time.sleep(6)
    
    if __name__ == "__main__":
        main()    
\end{pythoncode}
\subsubsection{Luli\_pH.py}
\begin{pythoncode}[caption={Pico W pH Sensor Code}]
    from machine import ADC, Pin
    import utime
    import Luli_CONFIG
    
    class PHSensor:
        # Constants for pH calculation
        VOLTAGE_AT_PH7 = Luli_CONFIG.VOLTAGE_AT_PH7  # Voltage at pH 7
        VOLTAGE_AT_PH4 = Luli_CONFIG.VOLTAGE_AT_PH4  # Voltage at pH 4
        PH_STEP = (VOLTAGE_AT_PH7 - VOLTAGE_AT_PH4) / (7 - 4)  # Voltage change per pH unit
    
        def __init__(self, pin_number=Luli_CONFIG.PIN_PH_SENSOR):
            self.adc = ADC(Pin(pin_number))  # Initialize ADC on specified pin
    
        def read_sensor(self):
            buf = []
            for _ in range(10):
                adc_value = self.adc.read_u16()
                buf.append(adc_value)
                utime.sleep_ms(Luli_CONFIG.DELAY_PH_RESPONSE)  # Sleep to match sensor response time
            buf.sort()
            avg_adc_value = sum(buf[1:-1]) / (len(buf) - 2)  # Calculate average excluding outliers
            return avg_adc_value
    
        def adc_to_ph(self, adc_value):
            voltage = adc_value * (3.3 / 65535)  # Convert ADC value to voltage
            ph_value = 7 + (self.VOLTAGE_AT_PH7 - voltage) / self.PH_STEP  # Calculate pH
            return ph_value
    
        def get_ph(self):
            avg_adc_value = self.read_sensor()
            return self.adc_to_ph(avg_adc_value)
    
    def main():
        ph_sensor = PHSensor()
        while True:
            ph = ph_sensor.get_ph()
            print("Sensor pH level =", ph)
            utime.sleep(2)
    
    if __name__ == "__main__":
        main()
        
\end{pythoncode}
\subsubsection{Luli\_Ultrasonic.py}
\begin{pythoncode}[caption={Pico W Ultrasonic Sensor Code}]
    import machine
    import utime
    import Luli_CONFIG
    
    class WaterLevelSensor:
        def __init__(self, trig_pin=Luli_CONFIG.PIN_ULTRASONIC_TRIG, echo_pin=Luli_CONFIG.PIN_ULTRASONIC_ECHO):
            self.trig = machine.Pin(trig_pin, machine.Pin.OUT)
            self.echo = machine.Pin(echo_pin, machine.Pin.IN)
            self.tank_full_distance = None
            self.tank_empty_distance = None
    
        def read_distance(self):
            self.trig.low()
            utime.sleep_us(5)
    
            self.trig.high()
            utime.sleep_us(10)
            self.trig.low()
    
            timeout = 10000  # Timeout in microseconds
    
            start_time = utime.ticks_us()
            while self.echo.value() == 0:
                if utime.ticks_diff(utime.ticks_us(), start_time) > timeout:
                    return None  # Timeout with no echo received
    
            signal_off = utime.ticks_us()
    
            start_time = utime.ticks_us()
            while self.echo.value() == 1:
                if utime.ticks_diff(utime.ticks_us(), start_time) > timeout:
                    return None  # Timeout while echo is still high
    
            signal_on = utime.ticks_us()
    
            time_passed = utime.ticks_diff(signal_on, signal_off)
            distance = (time_passed * 0.0343) / 2  # Convert time to distance
            return distance
    
        def calibrate_tank_full(self):
            print("Calibrating tank full... Please ensure the tank is full.")
            utime.sleep(5)
            self.tank_full_distance = self.read_distance()
            if self.tank_full_distance is not None:
                print("Tank full distance calibrated at:", self.tank_full_distance, "cm")
            else:
                print("Calibration failed. Make sure the tank is full and try again.")
    
        def calibrate_tank_empty(self):
            print("Calibrating tank empty... Please ensure the tank is empty.")
            utime.sleep(5)
            self.tank_empty_distance = self.read_distance()
            if self.tank_empty_distance is not None:
                print("Tank empty distance calibrated at:", self.tank_empty_distance, "cm")
            else:
                print("Calibration failed. Make sure the tank is empty and try again.")
    
        def display_water_level(self):
            distance = self.read_distance()
            if distance is not None and distance > 2:
                if self.tank_full_distance is not None and self.tank_empty_distance is not None:
                    water_level = self.tank_empty_distance - distance
                    tank_capacity = self.tank_empty_distance - self.tank_full_distance
                    percent_full = (water_level / tank_capacity) * 100
                    print("Water level:", round(percent_full, 2), "% full")
                else:
                    print("Tank 'full' or 'empty' distance not calibrated.")
            else:
                print("Out of range, too close, or sensor error.")
    
        def get_water_level(self):
            distance = self.read_distance()
            if distance is not None and distance > 2:
                if self.tank_full_distance is not None and self.tank_empty_distance is not None:
                    water_level = self.tank_empty_distance - distance
                    tank_capacity = self.tank_empty_distance - self.tank_full_distance
                    percent_full = (water_level / tank_capacity) * 100
                    return round(percent_full, 2)
                else:
                    return None
            else:
                return None
    
    def main():
        sensor = WaterLevelSensor()
        # Uncomment to calibrate on startup
        # sensor.calibrate_tank_full()
        # sensor.calibrate_tank_empty()
    
        while True:
            sensor.display_water_level()
            utime.sleep(1)
    
    if __name__ == "__main__":
        main()
    
    
\end{pythoncode}
\subsubsection{Luli\_UV.py}
\begin{pythoncode}[caption={Pico W UV Sensor Code}]
    # Adapted from  https://forums.pimoroni.com/t/ltr390-micropython-code/22314/2
    import utime
    from machine import Pin, I2C
    import Luli_CONFIG
    
    class LTR390:
        # Constants
        ADDR = 0x53
        MAIN_CTRL = 0x00
        MEAS_RATE = 0x04
        GAIN = 0x05
        PART_ID = 0x06
        MAIN_STATUS = 0x07
        ALSDATA = 0x0D
        UVSDATA = 0x10
        INT_CFG = 0x19
        INT_PST = 0x1A
        THRESH_UP = 0x21
        THRESH_LOW = 0x24
        RESOLUTION_20BIT_utime400MS = 0x00
        RESOLUTION_19BIT_utime200MS = 0x10
        RESOLUTION_18BIT_utime100MS = 0x20  # Default
        RESOLUTION_17BIT_utime50MS = 0x03
        RESOLUTION_16BIT_utime25MS = 0x40
        RESOLUTION_13BIT_utime12_5MS = 0x50
        RATE_25MS = 0x0
        RATE_50MS = 0x1
        RATE_100MS = 0x2  # Default
        RATE_200MS = 0x3
        RATE_500MS = 0x4
        RATE_1000MS = 0x5
        RATE_2000MS = 0x6
        GAIN_1 = 0x0
        GAIN_3 = 0x1  # Default
        GAIN_6 = 0x2
        GAIN_9 = 0x3
        GAIN_18 = 0x4
    
        def __init__(self):
            self.i2c = I2C(0, scl=Pin(Luli_CONFIG.PIN_UV_SENSOR_SCL), sda=Pin(Luli_CONFIG.PIN_UV_SENSOR_SDA), freq=100000)
            self.ID = self.read_byte(self.PART_ID)
            if self.ID != 0xB2:
                print("Read ID error! Check the hardware...")
                return
            self.write_byte(self.MAIN_CTRL, 0x0A)  # UVS in Active Mode
            self.write_byte(self.MEAS_RATE, self.RESOLUTION_20BIT_utime400MS | self.RATE_2000MS)
            self.write_byte(self.GAIN, self.GAIN_18)
    
        def read_byte(self, cmd):
            data = self.i2c.readfrom_mem(self.ADDR, cmd, 1)
            return data[0]
    
        def write_byte(self, cmd, val):
            self.i2c.writeto_mem(self.ADDR, cmd, bytes([val]))
    
        def read_uvs(self):
            data1 = self.read_byte(self.UVSDATA)
            data2 = self.read_byte(self.UVSDATA + 1)
            data3 = self.read_byte(self.UVSDATA + 2)
            return (data3 << 16) | (data2 << 8) | data1
        
        def get_uv_intensity(self):
            raw_uvs = self.read_uvs()
            
            uv_intensity = (raw_uvs / Luli_CONFIG.UVS_CONVERSION_FACTOR) * 1000
            return uv_intensity
        
        def get_uv_data(self):
            raw_uvs = self.read_uvs()
            uv_intensity = (raw_uvs / Luli_CONFIG.UVS_CONVERSION_FACTOR) * 1000
            return raw_uvs, uv_intensity
        
    
    
    if __name__ == '__main__':
        sensor = LTR390()
        utime.sleep(1)
        try:
            while True:
                raw, uv_intensity = sensor.get_uv_data()
                print("RAW: {}".format(raw))
                print("UV intensity: {}".format(uv_intensity))
                #return raw, uv_intensity
                #return uv_intensity
        except KeyboardInterrupt:
            print("Interrupted by user")
            exit()
    
    
\end{pythoncode}
\subsubsection{MUX\_Test\_Code.py}
\label{appendix:muxTest}
\begin{pythoncode}[caption={Pico W MUX Test Code}]
    from machine import Pin, ADC
    import time
    
    # Setup the data pin
    data_pin = ADC(Pin(28))  # Assuming GPIO0 is set up as ADC for voltage reading
    
    # Setup select pins
    sA = Pin(2, Pin.OUT)
    sB = Pin(3, Pin.OUT)
    sC = Pin(4, Pin.OUT)
    
    def select_input(a, b, c):
        """Set the select pins based on the desired input"""
        sA.value(a)
        sB.value(b)
        sC.value(c)
    
    def read_voltage():
        """Read and return the voltage from the ADC connected to the MUX output"""
        voltage = data_pin.read_u16() * 3.3 / 65535  # Convert ADC reading to voltage (3.3V reference)
        return voltage
    
    
    while True:
        # Test the MUX by selecting different inputs and printing the read voltage
        for input_number in range(3):  # Test for D0, D1, and D2
            select_input((input_number & 0x4) >> 2, (input_number & 0x2) >> 1, input_number & 0x1)
            time.sleep(1)  # Wait a bit for MUX to stabilize and ADC to settle
            voltage = read_voltage()
            print(f"Input {input_number}: Voltage = {voltage:.2f} V")
    
    
\end{pythoncode}
\subsection{Flask Backend Python Code}
\subsubsection{main.py}
\begin{pythoncode}[caption={Main Flask Backend Code}]
    #########################################
    #           Luli Hydroponics            #
    #      Backend Code made with Flask    #
    #########################################
    
    
    from flask import Flask, render_template, request, redirect, url_for, flash, session, make_response, jsonify
    import os
    from pymongo import MongoClient
    from bson.objectid import ObjectId
    from werkzeug.security import generate_password_hash, check_password_hash
    from werkzeug.utils import secure_filename
    from dotenv import load_dotenv
    from datetime import datetime
    import uuid
    
    """
    ROUTES and METHODS
    - '/' : GET
    - '/create_account' : GET, POST
    - '/login' : GET, POST
    - '/logout' : GET
    - '/plants' : GET
    - '/forum' : GET
    - '/add_post' : POST
    - '/friends' : GET
    - '/save_settings' : POST
    - '/settings' : GET
    - '/download_settings/<friend_id>' : GET
    - '/control_panel' : GET
    
    """
    
    
    # Get the absolute path to the directory where the script is located
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))
    
    
    # Construct the absolute paths to 'static' and 'templates' folders
    absolute_static_path = os.path.join(BASE_DIR, '..', 'frontend', 'static')
    absolute_templates_path = os.path.join(BASE_DIR, '..', 'frontend', 'templates')
    absolute_user_images_path = os.path.join(BASE_DIR, '..', 'frontend', 'static', 'USER_IMAGES')
    
    # Normalize the paths to remove any relative path components (like '..')
    absolute_static_path = os.path.normpath(absolute_static_path)
    absolute_templates_path = os.path.normpath(absolute_templates_path)
    absolute_user_images_path = os.path.normpath(absolute_user_images_path)
    
    
    # MongoDB connection setup
    mongodb_connection_string = 'mongodb://localhost:27017'
    # brew services start mongodb/brew/mongodb-community
    
    client = MongoClient(mongodb_connection_string) 
    DATABASE = client['user_data']  
    users_collection = DATABASE.credentials
    users_messages_collection = DATABASE.messages
    users_settings_collection = DATABASE.settings
    users_data_collection = DATABASE.data
    
    app = Flask(__name__,
                static_url_path='', 
                static_folder=absolute_static_path,
                template_folder=absolute_templates_path )
    
    load_dotenv() # Load .env file data
    app.secret_key = os.getenv("luli_secret_key") # Load secret key into flask app
    os.environ.pop('luli_secret_key', None) # Delete secret key from environment variables
    
    
    app.config['SESSION_COOKIE_SECURE'] = True  # Only send cookies over HTTPS.
    app.config['SESSION_COOKIE_HTTPONLY'] = True  # Prevent client-side JS from accessing the cookie.
    app.config['IMAGE_UPLOAD_FOLDER'] = absolute_user_images_path
    app.config['PROFILE_PIC_FOLDER'] = os.path.join(absolute_static_path, 'PROFILE_PICS')
    app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max size
    # Ensure the directory exists
    os.makedirs(app.config['IMAGE_UPLOAD_FOLDER'], exist_ok=True)
    os.makedirs(app.config['PROFILE_PIC_FOLDER'], exist_ok=True)
    
    #app.config['PERMANENT_SESSION_LIFETIME'] = 600  # Session lifetime in seconds or use timedelta for more precision.
    
    
    # Import the function to register API routes after the app instance is created
    from api import register_api_routes
    
    # Call the register function with the app object to set up the api endpoints
    register_api_routes(app, users_data_collection=users_data_collection, users_settings_collection=users_settings_collection, users_collection=users_collection)
    
    #################
    #   HOMEPAGE    #
    #################
    @app.route('/')
    def serve_welcome_page():
        return app.send_static_file('Luli.html')
    
    
    #######################
    #   CREATE ACCOUNT    #
    #######################
    @app.route('/create_account', methods=['GET', 'POST'])
    def create_account():
        if request.method == 'POST':
            first_name = request.form['first-name']
            last_name = request.form['last-name']
            username = request.form['username']
            password = request.form['password']
            profile_pic = request.files['profile_pic']
            # Check if the username already exists in the database
            if users_collection.find_one({'username': username}):
                return "Username already exists. Choose a different one."
            
            # Hash the password for security
            hashed_password = generate_password_hash(password)
    
            # Insert new user into the database
            current_time = datetime.now()
            result = users_collection.insert_one({
                'first_name': first_name, 
                'last_name': last_name,
                'username': username, 
                'password': hashed_password, 
                'created': current_time,
                'friends': []  # Initialize an empty list for friends
            })
            
            # Retrieve the new user's ID
            new_user_id = result.inserted_id
    
            if profile_pic and allowed_file(profile_pic.filename):
                filename = secure_filename(profile_pic.filename)
                # Standardize the file extension
                if filename.lower().endswith('.jpeg'):
                    filename = filename[:-5] + '.jpg'  # Change extension from .jpeg to .jpg
    
                filename = username + '.jpg'  # Rename the file to username.jpg
                profile_pic_path = os.path.join(app.config['PROFILE_PIC_FOLDER'], filename)
                profile_pic.save(profile_pic_path)
            
            # Retrieve all existing users to add to the new user's friend list, excluding the new user themselves
            all_users = users_collection.find({'_id': {'$ne': new_user_id}}, {'_id': 1, 'username': 1})
            friends_list = [{'username': user['username'], 'user_id': str(user['_id'])} for user in all_users]
            
            # Add existing users to the new user's friend list
            users_collection.update_one({'_id': new_user_id}, {'$set': {'friends': friends_list}})
            
            # Also add this new user to existing users' friends lists
            users_collection.update_many({'_id': {'$ne': new_user_id}}, {'$push': {'friends': {'username': username, 'user_id': str(new_user_id)}}})
    
            # Initialize empty entries in other collections
            users_settings_collection.insert_one({'user_id': new_user_id, 'settings': {}})
            users_data_collection.insert_one({'user_id': new_user_id, 'data': {}})
            users_messages_collection.insert_one({'user_id': new_user_id, 'messages': {}})
            
            return redirect(url_for('login'))
        else:
            # Serve the static HTML file for the account creation form
            return app.send_static_file('CreateAccount.html')
        
    def allowed_profile_pic(filename):
        return '.' in filename and filename.rsplit('.', 1)[1].lower() in {'jpg', 'jpeg'}
    
    ##############
    #   LOGIN    #
    ##############
    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            username = request.form['username']
            password = request.form['password']
            user_document = users_collection.find_one({'username': username})
    
            if user_document and check_password_hash(user_document.get('password'), password):
                # Login successful
                session["logged_in"] = True
                session["username"] = username
                session["user_id"] = str(user_document['_id'])
                users_collection.update_one({'_id': user_document['_id']}, {'$set': {'last_login': datetime.now()}})
                return redirect(url_for('plants'))
            else:
                # Incorrect credentials, redirect with error message
                return redirect(url_for('login', msg='Incorrect credentials.'))
        else:
            # Serve the login page
            return app.send_static_file('Luli.html')
    
    ###############
    #   LOGOUT    #
    ###############
    @app.route('/logout', methods=['GET'])
    def logout():
        session.clear()
        return redirect(url_for('login'))
    
    
    #########################
    #   PLANTS + SENSORS    #
    #########################
    @app.route('/plants')
    def plants():
        user_id = session.get('user_id')
        if not user_id:
            return redirect(url_for('login'))
    
        sensor_data_document = users_data_collection.find_one({'user_id': ObjectId(user_id)})
    
        if sensor_data_document and 'sensor_data' in sensor_data_document:
            sensor_data = sensor_data_document['sensor_data']
            latest_sensor_data = list(sensor_data.values())[-1] if sensor_data else {}
        else:
            # Default empty data if there's no sensor data available
            latest_sensor_data = {
                'light': 'N/A',
                'temp': 'N/A',
                'humidity': 'N/A',
                'ph': 'N/A',
                'tank': 'N/A'
            }
    
        return render_template('Plants.html', sensor_data=latest_sensor_data)
       
    ##############
    #   FORUM    #
    ##############
    @app.route('/forum')
    def forum():
        posts = list(users_messages_collection.find())
        return render_template('Forum.html', posts=posts)
    
    
    @app.route('/add_post', methods=['POST'])
    def add_post():
        if 'user_id' not in session:
            return redirect(url_for('login'))  # Redirect to login if not logged in
    
        user_document = users_collection.find_one({'_id': ObjectId(session['user_id'])})
        if not user_document:
            return "User not found", 404
    
        message = request.form.get('message')
        image = request.files.get('image')
        
        post = {'user_id': session['user_id'], 
                'name': user_document.get('first_name'), 
                'message': message, 
                'created': datetime.now()}
    
        if image and allowed_file(image.filename):
            try:
                # Generate a unique filename using UUID
                unique_filename = str(uuid.uuid4())
                file_extension = os.path.splitext(secure_filename(image.filename))[1]
                filename = unique_filename + file_extension
                # The relative path for use in HTML src attribute
                relative_image_path = os.path.join('USER_IMAGES', filename)
                # The absolute path to save the image file
                absolute_image_path = os.path.join(app.config['IMAGE_UPLOAD_FOLDER'], filename)
                # Save the image
                image.save(absolute_image_path)
                # Add image path to the post dictionary
                post['image_path'] = relative_image_path  # Store the relative path, not absolute
                print(f"Image saved with unique filename {filename}")
            except Exception as e:
                print(f"Failed to save image: {e}")
                return "Failed to save image", 500
    
        # Insert the post (with the image path if there's an image) into the database
        users_messages_collection.insert_one(post)
        return redirect(url_for('forum')) 
    
    
    def allowed_file(filename):
        ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}
        # Check if there is an extension in the filename and if the extension is allowed
        return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
    
    
    ###############
    #   FRIENDS   #
    ###############
    @app.route('/friends')
    def friends():
        if 'user_id' not in session:
            return redirect(url_for('login'))  # Ensure the user is logged in
    
        user_id = session['user_id']
        user_document = users_collection.find_one({'_id': ObjectId(user_id)})
    
        if 'friends' in user_document:
            # Extract the user_id of each friend and convert to ObjectId
            friend_ids = [ObjectId(friend['user_id']) for friend in user_document['friends']]
            friends = users_collection.find({'_id': {'$in': friend_ids}})
            friends_list = list(friends)  # Convert cursor to list for passing to template
            return render_template('Friends.html', friends=friends_list)
        else:
            # Handle case where no friends are stored or the field is missing
            return render_template('Friends.html', friends=[])
    
    
    
    
    #################
    #   SETTINGS    #
    #################
    @app.route('/save_settings', methods=['POST'])
    def save_settings():
        if 'user_id' not in session:
            return redirect(url_for('login'))
    
        user_id = session['user_id']
        water_interval = request.form.get('water_interval')
        led_duration = request.form.get('led_duration')
        pump_duration = request.form.get('pump_duration')
        # ... other settings values
    
        users_settings_collection.update_one(
            {'user_id': ObjectId(user_id)},
            {'$set': {
                'water_interval': water_interval,
                'led_duration': led_duration,
                'pump_duration': pump_duration
                # ... other settings
            }},
            upsert=True
        )
        return redirect(url_for('settings_page'))
    
    
    @app.route('/settings')
    def settings_page():
        if 'user_id' not in session:
            return redirect(url_for('login'))
    
        user_id = session['user_id']
        settings = users_settings_collection.find_one({'user_id': ObjectId(user_id)})
        print("GOT SETTINGS: ", settings)
        if settings is None:
            # Set defaults if no settings are found
            print("settings is None!")
            settings = {
                'water_interval': '12',
                'led_duration': '12',
                'pump_duration': '5',
                # Include defaults for any other settings
            }
        else:
            # If settings exist, remove MongoDB's _id before passing to template
            settings.pop('_id', None)
        
        return render_template('settings.html', settings=settings)
    
    @app.route('/download_settings/<friend_id>')
    def download_settings(friend_id):
        print("SAVING SETTINGS FROM FRIEND: ", friend_id)
        settings = users_settings_collection.find_one({'user_id': ObjectId(friend_id)})
        if settings:
            del settings['_id']  # Remove the MongoDB ID before sending
            return jsonify(settings)
        # Now get current user's document
        user_id = session['user_id']
        user_settings = users_settings_collection.find_one({'user_id': ObjectId(user_id)})
        # Now overwrite user_settings with settings from friend
        # But don't overwrite the user_id
        user_settings.update(settings)
        return jsonify({'error': 'Settings not found'}), 404
    
    
    #################
    # CONTROL PANEL #
    #################
    @app.route('/control_panel')
    def control_panel():
        user_id = session.get('user_id')
        if not user_id:
            return redirect(url_for('login'))
        user_data = users_collection.find_one({'_id': ObjectId(user_id)})
        device_id = user_data.get('device_id') if user_data else None
        if device_id:
            return render_template('ControlPanel.html', device_id=device_id)
        else:
            return "Device ID not found", 404
    
    
    
    if __name__ == "__main__":
        ### How to run this file ###
        """
        1. Create a virtualenv and install packages
            $ pip3 install virtualenv           [ only run this once ]
            $ virtualenv venv                   [ this create a virtual python environment called "venv" ]
            $ activate venv/bin/activate        [ mac only, this is how to enable the venv so it doesnt install packages to your global python ]
            $ pip install -r requirements.txt   [ this installs the necessary modules for the code to run (i.e. Flask) ]
        2. cd Luli/backend
        3. Make sure MongoDB is running         [ On Mac: brew services start mongodb-community ]
        4. python main.py
        5. View the url in the output           [ If running locally: http://127.0.0.1:9696 ]
        6. Open it in browser
        """
    
    
        print("Starting Flask server...")
        app.run(debug=True, port=9696, host="0.0.0.0")    
\end{pythoncode}
\subsubsection{api.py}
\begin{pythoncode}[caption={Flask Backend API Code}]
    from flask import request, jsonify
    from bson.objectid import ObjectId
    import datetime
    from functools import wraps
    
    #############################
    #       API FUNCTIONS       #
    #############################
    '''
        List of Valid API Endpoints and Their Methods:
        ENDPOINT:                       METHODS:
        - /api/test                     GET
        - /api/get_hardware_id          GET
        - /api/set_hardware_id          POST
        - /api/update_settings          POST
        - /api/get_settings             GET
        - /api/get_humidity_data        GET
        - /api/get_uv_data              GET
        - /api/get_ph_data              GET
        - /api/get_temp_data            GET
        - /api/get_tank_data            GET
        - /api/get_all_data             GET
        - /api/update_uv_data           POST
        - /api/update_ph_data           POST
        - /api/update_temp_data         POST
        - /api/update_humidity_data     POST
        - /api/update_tank_data         POST
        - /api/update_all_sensors_data  POST
        - /api/update_manual_override   POST
        - /api/get_manual_override      GET
    '''
    
    # Do it all in a function here because we can pass it "app" which is the same "app" as main.py
    # this way avoids circular imports and lets us clean up the main.py file and keep the API defined here
    
    
    
    def register_api_routes(app, users_settings_collection, users_data_collection, users_collection):
        # This dictionary will store the manual override commands for each device by its ID
        device_override_commands = {}
    
    
        def ensure_object_id(obj_id):
            if isinstance(obj_id, str):
                try:
                    return ObjectId(obj_id)
                except Exception as e:
                    print(f"Error converting string to ObjectId: {e}")
                    return None  # or handle the error as needed
            elif isinstance(obj_id, ObjectId):
                return obj_id
            else:
                print("Invalid type for user ID.")
                return None  # or handle as needed
            
        def validate_API_key(device_id):
            # Device ID will come from: request.headers.get('X-Device-ID')
            if device_id is None:
                return False, None, jsonify({'message': 'X-Device-ID is required'}), 400
            else: 
                # Check if the device ID is a string
                if not isinstance(device_id, str):
                    return False, None, jsonify({'message': 'Invalid X-Device-ID format'}), 400
                
                # Check if the length of the hardware ID is correct
                if len(device_id) != 16:  # Assuming 16 characters for a 128-bit ID
                    return False, None, jsonify({'message': 'Invalid X-Device-ID format'}), 400
        
                # Check if the hardware ID contains only hexadecimal characters
                valid_chars = set("0123456789abcdefABCDEF")
                if not all(char in valid_chars for char in device_id):
                    return False, None, jsonify({'message': 'Invalid X-Device-ID format'}), 400
        
            user = users_data_collection.find_one({"device_id": device_id})
            if user is None:
                return False, None, jsonify({'message': 'Unauthorized - Device not recognized'}), 401
            
            return True, ensure_object_id(user['_id']), jsonify({'message': 'Authentication Successful'}), 200
        
        # Custom Decorator to require an API key on certain routes
        def require_api_key(f):
            @wraps(f)
            def decorated_function(*args, **kwargs):
                valid_api_key, user_id, message, status_code = validate_API_key(request.headers.get('X-Device-ID'))
                if not valid_api_key:
                    return jsonify({'message': message}), status_code
                return f(*args, **kwargs, user_id=user_id)
            return decorated_function
            
        # Custom test function to manually add data to the database
        def add_sensor_data(client, database_name, collection_name, document_id, sensor_data):
            # Access the MongoDB database
            db = client[database_name]
            collection = db[collection_name]
            
            # Timestamp as a string in ISO format, with colons replaced by underscores
            #timestamp = datetime.utcnow().isoformat().replace('.', ':') + '+00_00'
            timestamp = datetime.now().isoformat().replace('.', ':')
    
            # Update the document with new sensor data at the specified timestamp
            print(f"TIMESTAMP IS: {timestamp}")
            update_result = collection.update_one(
                {"_id": document_id},
                {"$set": {f"sensor_data.{timestamp}": sensor_data}},
                upsert=True
            )
            
            # Check the result of the update
            if update_result.upserted_id is not None:
                print(f"Document was created with ID: {update_result.upserted_id}")
            elif update_result.modified_count == 1:
                print("Update successful.")
            else:
                print("Update failed or no changes made.")
    
        
    
        ## USER SETTINGS
        @app.route('/api/get_settings', methods=['GET'])
        @require_api_key
        def api_get_settings(user_id):
            user_settings = users_settings_collection.find_one({'user_id': user_id})
            if not user_settings:
                return "No settings found for this user."
            return user_settings['settings']
    
        @app.route('/api/update_settings', methods=['POST'])
        @require_api_key
        def api_update_settings(user_id):
            user_settings = users_settings_collection.find_one({'user_id': user_id})
            if not user_settings:
                users_settings_collection.insert_one({'user_id': user_id, 'settings': request.json})
            else:
                users_settings_collection.update_one({'user_id': user_id}, {'$set': {'settings': request.json}})
            return "Settings updated successfully."
    
        @app.route('/api/set_hardware_id', methods=['POST'])
        def api_set_hardware_id():
            # Get the username and device_id passed in the request json:
            payload = request.get_json()
            username = payload.get('username')
            device_id = payload.get('device_id')
            user_credentials = users_collection.find_one({'username': username})
            if not user_credentials:
                return jsonify({'message': 'User not found'}), 404
            else:
                users_collection.update_one({'username': username}, {'$set': {'device_id': device_id}})
            return jsonify({'message': 'Hardware ID updated successfully'}), 200
        
        @app.route('/api/get_hardware_id', methods=['GET'])
        @require_api_key
        def api_get_hardware_id(user_id):
            user_credentials = users_collection.find_one({'user_id': user_id})
            if not user_credentials:
                return jsonify({'message': 'User not found'}), 404
            return user_credentials['hardware_id']
    
        ## SENSOR READINGS - GET
    
        @app.route('/api/get_light_data', methods=['GET'])
        @require_api_key
        def api_get_light_data(user_id):
            user_data = users_data_collection.find_one({'user_id': user_id})
            if not user_data:
                #return "No data found for this user."
                return jsonify({'message': 'No data found for this user'}), 404
            return user_data['light']
    
        @app.route('/api/get_ph_data', methods=['GET'])
        @require_api_key
        def api_get_ph_data(user_id):
            user_data = users_data_collection.find_one({'user_id': user_id})
            if not user_data:
                #return "No data found for this user."
                return jsonify({'message': 'No data found for this user'}), 404
            return user_data['ph']
    
        @app.route('/api/get_temp_data', methods=['GET'])
        @require_api_key
        def api_get_temp_data(user_id):
            user_data = users_data_collection.find_one({'user_id': user_id})
            if not user_data:
                #return "No data found for this user."
                return jsonify({'message': 'No data found for this user'}), 404
            return user_data['temp']
    
        @app.route('/api/get_humidity_data', methods=['GET'])
        @require_api_key
        def api_get_humidity_data(user_id):
            user_data = users_data_collection.find_one({'user_id': user_id})
            if not user_data:
                #return "No data found for this user."
                return jsonify({'message': 'No data found for this user'}), 404
            return user_data['humidity']
        
        @require_api_key
        def api_get_tank_data(user_id):
            user_data = users_data_collection.find_one({'user_id': user_id})
            if not user_data:
                #return "No data found for this user."
                return jsonify({'message': 'No data found for this user'}), 404
            return user_data['tank']
    
        @app.route('/api/get_all_data', methods=['GET'])
        @require_api_key
        def api_get_all_data(user_id):
            user_data = users_data_collection.find_one({'user_id': user_id})
            if not user_data:
                #return "No data found for this user."
                return jsonify({'message': 'No data found for this user'}), 404
            return user_data
    
        ## SENSOR READINGS - POST
        @app.route('/api/update_light_data', methods=['POST'])
        @require_api_key
        def api_update_light_data(user_id):
            user_data = users_data_collection.find_one({'user_id': user_id})
            if not user_data:
                users_data_collection.insert_one({'user_id': user_id, 'light': request.json})
            else:
                users_data_collection.update_one({'user_id': user_id}, {'$set': {'light': request.json}})
            #return "Light Data updated successfully."
            return jsonify({'message': 'Light Data updated successfully'}), 200
    
        @app.route('/api/update_ph_data', methods=['POST'])
        @require_api_key
        def api_update_pH_data(user_id):
            user_data = users_data_collection.find_one({'user_id': user_id})
            if not user_data:
                users_data_collection.insert_one({'user_id': user_id, 'ph': request.json})
            else:
                users_data_collection.update_one({'user_id': user_id}, {'$set': {'ph': request.json}})
            #return "pH Data updated successfully."
            return jsonify({'message': 'pH Data updated successfully'}), 200
    
        @app.route('/api/update_temp_data', methods=['POST'])
        @require_api_key
        def api_update_temp_data(user_id):
            user_data = users_data_collection.find_one({'user_id': user_id})
            if not user_data:
                users_data_collection.insert_one({'user_id': user_id, 'temp': request.json})
            else:
                users_data_collection.update_one({'user_id': user_id}, {'$set': {'temp': request.json}})
            #return "Temperature Data updated successfully."
            return jsonify({'message': 'Temperature Data updated successfully'}), 200
    
        @app.route('/api/update_humidity_data', methods=['POST'])
        @require_api_key
        def api_update_humidity_data(user_id):
            user_data = users_data_collection.find_one({'user_id': user_id})
            if not user_data:
                users_data_collection.insert_one({'user_id': user_id, 'humidity': request.json})
            else:
                users_data_collection.update_one({'user_id': user_id}, {'$set': {'humidity_data': request.json}})
            #return "Humidity Data updated successfully."
            return jsonify({'message': 'Humidity Data updated successfully'}), 200
    
        @app.route('/api/update_tank_data', methods=['POST'])
        @require_api_key
        def api_update_tank_data(user_id):
            user_data = users_data_collection.find_one({'user_id': user_id})
            if not user_data:
                users_data_collection.insert_one({'user_id': user_id, 'tank': request.json})
            else:
                users_data_collection.update_one({'user_id': user_id}, {'$set': {'tank': request.json}})
            #return "Tank Data updated successfully."
            return jsonify({'message': 'Tank Data updated successfully'}), 200
    
    
        @app.route('/api/update_all_sensor_data', methods=['POST'])
        @require_api_key
        def update_all_sensor_data(user_id):
            sensor_data = request.get_json()
            if not sensor_data:
                return jsonify({'message': 'No sensor data provided'}), 400
            # Update the document with new sensor data at the specified timestamp
            print(f"TIMESTAMP IS: {timestamp}")    
            timestamp = datetime.datetime.now().isoformat().replace('.', ':')
            # Check if the user already has sensor data
            if users_data_collection.count_documents({'_id': user_id, 'sensor_data': {'$exists': True}}) == 0:
                # If not, create a new document with sensor_data as a dictionary
                users_data_collection.insert_one({'_id': user_id, 'sensor_data': {timestamp: sensor_data}})
            else:
                # If sensor_data exists, update the existing document with new sensor data at the specified timestamp
                users_data_collection.update_one(
                    {"_id": user_id},
                    {"$set": {f"sensor_data.{timestamp}": sensor_data}},
                    upsert=True
                )
    
            #return "All sensor data updated successfully."
            return jsonify({'message': 'All sensor data updated successfully'}), 200
        
        @app.route('/api/test', methods=['GET'])
        def api_test():
            return "API is working."
        
        @app.route('/api/update_manual_override/<device_id>', methods=['POST'])
        def update_manual_override(device_id):
            content = request.json
            if device_id not in device_override_commands:
                device_override_commands[device_id] = {}
            device_override_commands[device_id].update(content)
            return jsonify(success=True, commands=device_override_commands[device_id]), 200
    
        @app.route('/api/get_manual_override/<device_id>', methods=['GET'])
        def get_manual_override(device_id):
            commands = device_override_commands.get(device_id, {})
            # Clear the commands after they have been fetched
            device_override_commands[device_id] = {}
            return jsonify(commands), 200
\end{pythoncode}
\subsubsection{messaging.py}
\begin{pythoncode}[caption={Messaging Functions for MongoDB}]
    from pymongo import MongoClient
    from pymongo.errors import DuplicateKeyError
    from bson.objectid import ObjectId
    
    def follow_user(FROM_user_id, TO_user_id, mongoclient_url='mongodb://localhost:27017'):
        user_id = ObjectId(FROM_user_id)
        user_to_follow_id = ObjectId(TO_user_id)
        
        client = MongoClient(mongoclient_url)
        DATABASE = client['user_data']
        users_collection = DATABASE.credentials
        
        # Make sure users exist
        user = users_collection.find_one({'_id': user_id})
        user_to_follow = users_collection.find_one({'_id': user_to_follow_id})
    
        # If both users exist and the user_to_follow is not already in the followed_users list, add the user_to_follow to the user's friends list
        print(user_to_follow_id not in user.get('followed_users', []))
        if user and user_to_follow and user_to_follow_id not in user.get('followed_users', []):
            # Check if the user already has a 'followed_users' field
            if 'followed_users' in user:
                # If the 'followed_users' field exists, append the user_to_follow_id to the list
                users_collection.update_one({'_id': user_id}, {'$push': {'followed_users': user_to_follow_id}})
            else:
                # If the 'followed_users' field does not exist, create a new list with the user_to_follow_id
                users_collection.update_one({'_id': user_id}, {'$set': {'followed_users': [user_to_follow_id]}})
            return True
        elif user_to_follow_id in user.get('followed_users', []):
            return True
        return False
    
    def get_followed_users(user_id, mongoclient_url='mongodb://localhost:27017'):
        user_id = ObjectId(user_id)
        
        client = MongoClient(mongoclient_url)
        DATABASE = client['user_data']
        users_collection = DATABASE.credentials
        
        user = users_collection.find_one({'_id': user_id})
        if user:
            return user.get('followed_users', [])
        return None
    
    def message_user(FROM_user_id, TO_user_id, message, mongoclient_url='mongodb://localhost:27017'):
        user_id = ObjectId(FROM_user_id)
        user_to_message_id = ObjectId(TO_user_id)
    
        client = MongoClient(mongoclient_url)
        DATABASE = client['user_data']
        users_collection = DATABASE.credentials
        users_messages_collection = DATABASE.messages
        
        # Make sure users exist
        user = users_collection.find_one({'_id': user_id})
        user_to_message = users_collection.find_one({'_id': user_to_message_id})
    
        # If both users exist, add the message to the database
        if user and user_to_message:
            users_messages_collection.insert_one({
                'sender_id': user_id,
                'receiver_id': user_to_message_id,
                'message': message
            })
            return True
        return False
    
    def get_most_recent_message(FROM_user_id, TO_user_id, mongoclient_url='mongodb://localhost:27017'):
        user_id = ObjectId(FROM_user_id)
        user_to_message_id = ObjectId(TO_user_id)
    
        client = MongoClient(mongoclient_url)
        DATABASE = client['user_data']
        users_messages_collection = DATABASE.messages
        
        # Query by 'receiver_id' instead of 'user_id'
        user_messages = users_messages_collection.find({'receiver_id': user_to_message_id})
        
        user_messages_list = list(user_messages)
        if len(user_messages_list) == 0:
            return None
        return user_messages_list[-1]
    
    def get_most_recent_message_from_user(FROM_user_id, TO_user_id, mongoclient_url='mongodb://localhost:27017'):
        user_id = ObjectId(FROM_user_id)
        user_to_message_id = ObjectId(TO_user_id)
    
        client = MongoClient(mongoclient_url)
        DATABASE = client['user_data']
        users_messages_collection = DATABASE.messages
        
        # Query by 'sender_id' instead of 'user_id'
        user_messages = users_messages_collection.find({'sender_id': user_id, 'receiver_id': user_to_message_id})
        
        user_messages_list = list(user_messages)
        if len(user_messages_list) == 0:
            return None
        return user_messages_list[-1]
    
    def user_id_to_username(user_id, mongoclient_url='mongodb://localhost:27017'):
        user_id = ObjectId(user_id)
        
        client = MongoClient(mongoclient_url)
        DATABASE = client['user_data']
        users_collection = DATABASE.credentials
        
        user = users_collection.find_one({'_id': user_id})
        if user:
            return user['username']
        return None
    
    def username_to_user_id(username, mongoclient_url='mongodb://localhost:27017'):
        client = MongoClient(mongoclient_url)
        DATABASE = client['user_data']
        users_collection = DATABASE.credentials
        
        userid = users_collection.find_one({'username': username})
        if userid:
            return userid['_id']
    
    
    def test_follow_user():
        user_id = username_to_user_id('Liam_TEST')
        user_to_follow_id = username_to_user_id('Luigi_TEST')
        assert follow_user(user_id, user_to_follow_id) == True
        assert follow_user(user_to_follow_id, user_id) == True
    
    
    def test_check_messages():
        user_id = ObjectId('6615f9b445f79acfdde258eb')  # Liam_TEST
        user_to_message_id = ObjectId('6615f98545f79acfdde258ea')  # Luigi_TEST
        message = "Hello, how are you?!!!"
        message_user(user_id, user_to_message_id, message)
        client = MongoClient()
        DATABASE = client['user_data']
        
        users_messages_collection = DATABASE.messages
        # Query by 'receiver_id' instead of 'user_id'
        user_messages = users_messages_collection.find({'receiver_id': user_to_message_id})
        
        user_messages_list = list(user_messages)
        assert len(user_messages_list) != 0
        assert message in [user_message['message'] for user_message in user_messages_list]
        
    
    if __name__ == "__main__":
        test_follow_user()
        test_check_messages()
        
    
        assert user_id_to_username(username_to_user_id('Liam_TEST')) == 'Liam_TEST'
        client = MongoClient()
        DATABASE = client['user_data']
        
        messages = DATABASE.messages.find({'receiver_id': ObjectId(username_to_user_id('Luigi_TEST'))})
        message_values = [message['message'] for message in messages]
        print("Messages for Luigi_TEST to read: ", message_values)
    
        messages = DATABASE.messages.find({'receiver_id': ObjectId(username_to_user_id('Liam_TEST'))})
        message_values = [message['message'] for message in messages]
        print("Messages for Liam_TEST to read: ", message_values)
    
        print("\n")
        most_recent_message = get_most_recent_message(username_to_user_id('Liam_TEST'), username_to_user_id('Luigi_TEST'))
        if most_recent_message:
            sender_username = user_id_to_username(most_recent_message['sender_id'])
            print(f"Most recent message for Luigi_TEST from {sender_username}: {most_recent_message['message']}")
        else:
            print("No recent message for Luigi_TEST")
        print("\n")
    
        most_recent_message = get_most_recent_message_from_user(username_to_user_id('Liam_TEST'), username_to_user_id('Luigi_TEST'))
        if most_recent_message:
            print(f"Most recent message from Liam_TEST to Luigi_TEST: {most_recent_message['message']}")
        else:
            print("No recent message from Liam_TEST to Luigi_TEST")
    
        followed_users = get_followed_users(username_to_user_id('Liam_TEST'))
        usernames = [user_id_to_username(user_id) for user_id in followed_users]
        print(f"Liam_TEST follows: {usernames}")
    
        print("All tests passed!")
\end{pythoncode}
\subsubsection{test\_save\_sensor\_data.py}
\begin{pythoncode}[caption={Debugging Code for Saving Sensor Data}]
    from pymongo import MongoClient
    from datetime import datetime
    from bson import ObjectId
    
    def add_sensor_data(client, database_name, collection_name, document_id, sensor_data):
        # Access the MongoDB database
        db = client[database_name]
        collection = db[collection_name]
        
        # Timestamp as a string in ISO format, with colons replaced by underscores
        #timestamp = datetime.utcnow().isoformat().replace('.', ':') + '+00_00'
        timestamp = datetime.now().isoformat().replace('.', ':')
    
        # Update the document with new sensor data at the specified timestamp
        print(f"TIMESTAMP IS: {timestamp}")
        update_result = collection.update_one(
            {"_id": document_id},
            {"$set": {f"sensor_data.{timestamp}": sensor_data}},
            upsert=True
        )
        
        # Check the result of the update
        if update_result.upserted_id is not None:
            print(f"Document was created with ID: {update_result.upserted_id}")
        elif update_result.modified_count == 1:
            print("Update successful.")
        else:
            print("Update failed or no changes made.")
    
    # Example usage
    client = MongoClient("mongodb://localhost:27017/")
    database_name = 'user_data'
    collection_name = 'data'
    document_id = ObjectId('65fa4c38972991d86e690014')
    sensor_data = {
        "temp": 25.45,
        "humidity": 63,
        "light": 25,
        "tank": 36,
        "ph": 7
    }
    
    add_sensor_data(client, database_name, collection_name, document_id, sensor_data)
    
\end{pythoncode}
\pagebreak
\section{Hardware Appendix}
\subsection{Datasheet: Raspberry Pi Pico W}
\includepdf[pages=-]{Datasheets/PICO.pdf}
\pagebreak
\subsection{Datasheet: PH4502C Analog pH Sensor}
\includepdf[pages=-]{Datasheets/PH.pdf}
\pagebreak
\subsection{Datasheet: IRLZ34NPBF MOSFET}
\label{appendix:mosfet}
\includepdf[pages=-]{Datasheets/MOSFET.pdf}
\pagebreak
\subsection{Datasheet: 1N4001RLG Diode}
\includepdf[pages=-]{Datasheets/DIODE.pdf}
\pagebreak
\subsection{Datasheet: 16ZLH220MEFCT16.3X11 Capacitor}
\includepdf[pages=-]{Datasheets/CAP.pdf}
\pagebreak
\subsection{Datasheet: SN74LS151N Multiplexer}
\includepdf[pages=-]{Datasheets/MUX.pdf}
\pagebreak
\subsection{Datasheet: LTR-390UV-01}
\label{appendix:ltr390}
\includepdf[pages=-]{Datasheets/LTR390.pdf}
\pagebreak
% References
\begin{thebibliography}{99}
    \bibitem{ref_ph_amazon} GAOHOU. (n.d.). PH0-14 Value Detect Sensor Module + PH Electrode Probe BNC For Arduino [Online]. Available: \url{https://www.amazon.com/dp/B0799BXMVJ?psc=1&ref=ppx_yo2ov_dt_b_product_details}
    \bibitem{ref_ipc_2221} IPC, "IPC-2221C - Generic Standard on Printed Board Design," IPC International, Bannockburn, IL, Standard, Dec. 2023. [Online]. Available: \url{https://shop.ipc.org/2221-STD-0-D-0-EN-C}
    \bibitem{ref_boveda} Boveda. "Boveda Size 60 (4 Pack) 69\% RH for Cigar." Boveda, [online] Available: \url{https://store.bovedainc.com/collections/for-cigars/products/boveda-size-60-4-pack-69-rh-for-cigar} 
    \bibitem{ref_uvforum} T. Tonygo2, "LTR390 Micropython Code," Pimoroni Community Forum, 04-Dec-2021. [Online]. Available: \url{https://forums.pimoroni.com/t/ltr390-micropython-code/22314/2}.
    \bibitem{ref_crocsee} "CrocSee DC 12V Mini Food Grade Self Priming Diaphragm Fresh Water Transfer Pump 1.3LPM, Replacement Pump for Ice Maker, Coffee Machine, Water Dispenser," Amazon. [Online]. Available: \url{https://www.amazon.com/CrocSee-Diaphragm-Transfer-Replacement-Dispenser/dp/B09XH1GYYQ}. 
    \bibitem{ref_gikfun} "Gikfun 12V DC Dosing Pump Peristaltic Dosing Head with Connector for Arduino Aquarium Lab Analytic DIY AE1207," Gikfun Store. [Online]. Available: \url{https://www.amazon.com/Gikfun-Peristaltic-Connector-Aquarium-Analytic/dp/B01IUVHB8E}. 
    \bibitem{ref_growled} "Plant Grow LED Light, OUEVA 16.4ft/5M 5050 SMD Waterproof Full Spectrum Red Blue 5:1 Growing Lamp for Aquarium Greenhouse Hydroponic Plant, Garden Flowers Veg Grow Light," OUEVA Store, [Online]. Available: \url{https://www.amazon.com/Plant-OUEVA-16-4ft-Waterproof-Spectrum/dp/B06XCJG4M6}.
    \bibitem{ref_oldled} "USB Black Light Strip, 6.6ft 10W UV LED Blacklight String Lights, 395-400nm, DC 5V, 120 Lamp Beads, Glow in the Dark for Halloween, Birthday, Party, Fluorescent Poster, Room, Bedroom Decoration," GREENIC Store, [Online]. Available: \url{https://www.amazon.com/Blacklight-395-400nm-Halloween-Fluorescent-Decoration/dp/B0B99L22B8}.
    \bibitem{ref_ltr390} Lite-On Inc., "LTR-390UV Final Datasheet." [Online]. Available: \url{https://optoelectronics.liteon.com/upload/download/DS86-2015-0004/LTR-390UV_Final_%20DS_V1%201.pdf}.
    \bibitem{ref_mosfet} Infineon Technologies AG, "IRLZ34NPBF Datasheet." [Online]. Available: \url{https://www.infineon.com/dgdl/irlz34npbf.pdf?fileId=5546d462533600a40153567206892720}.
    \bibitem{ref_capacitor} Rubycon Corporation, "ZLH Series Aluminum Electrolytic Capacitors." [Online]. Available: \url{https://www.rubycon.co.jp/wp-content/uploads/catalog-aluminum/ZLH.pdf}.
    \bibitem{ref_diode} ON Semiconductor, "1N4001, 1N4002, 1N4003, 1N4004, 1N4005, 1N4006, 1N4007 Axial-Lead Glass Passivated Standard Recovery Rectifiers Datasheet." [Online]. Available: \url{https://www.onsemi.com/pdf/datasheet/1n4001-d.pdf}.
    \bibitem{ref_phsensor} "PH Sensor PH-4502C Datasheet." [Online]. Available: \url{https://cdn.awsli.com.br/969/969921/arquivos/ph-sensor-ph-4502c.pdf}.
    \bibitem{ref_pico_w} Raspberry Pi Foundation, "Raspberry Pi Pico W Datasheet." [Online]. Available: \url{https://datasheets.raspberrypi.com/picow/pico-w-datasheet.pdf}.
    \bibitem{ref_mux} Texas Instruments, "SN54S151 Data Selector/Multiplexer Datasheet." [Online]. Available: \url{https://www.ti.com/lit/ds/symlink/sn54s151.pdf?ts=1714290231547}.
\end{thebibliography}
\end{document}
